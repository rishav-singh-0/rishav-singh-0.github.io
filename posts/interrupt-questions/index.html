<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Interrupt Questions | Rishav's Digital Garden</title>
<meta name=keywords content="OS/Interrupt"><meta name=description content="Q1: What happens if another interrupt occurs while a top half (ISR) is executing?
Answer:

By default, interrupts are disabled during the top half execution. When the CPU enters the ISR (via the IDT), it automatically clears the Interrupt Flag (IF) on x86 (using cli), preventing further interrupts until the ISR finishes.
Exception: Some architectures or configurations (e.g., nested interrupts) allow interrupts to preempt an ISR. For example:

IRQF_DISABLED (now deprecated): Previously controlled whether interrupts were disabled during the ISR. Modern kernels typically disable interrupts for all IRQ handlers by default.
Threaded interrupts (using IRQF_ONESHOT or IRQF_THREAD): The &ldquo;top half&rdquo; runs in a kernel thread with interrupts enabled.



Key Takeaway:"><meta name=author content><link rel=canonical href=https://rishav-singh-0.github.io/posts/interrupt-questions/><link crossorigin=anonymous href=/assets/css/stylesheet.2211ca3164be7830024f6aad2b3a2e520843a64f8f048445c3401c1249aa051d.css integrity="sha256-IhHKMWS+eDACT2qtKzouUghDpk+PBIRFw0AcEkmqBR0=" rel="preload stylesheet" as=style><link rel=icon href=https://rishav-singh-0.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://rishav-singh-0.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://rishav-singh-0.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://rishav-singh-0.github.io/apple-touch-icon.png><link rel=mask-icon href=https://rishav-singh-0.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://rishav-singh-0.github.io/posts/interrupt-questions/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://rishav-singh-0.github.io/posts/interrupt-questions/"><meta property="og:site_name" content="Rishav's Digital Garden"><meta property="og:title" content="Interrupt Questions"><meta property="og:description" content="Q1: What happens if another interrupt occurs while a top half (ISR) is executing? Answer:
By default, interrupts are disabled during the top half execution. When the CPU enters the ISR (via the IDT), it automatically clears the Interrupt Flag (IF) on x86 (using cli), preventing further interrupts until the ISR finishes. Exception: Some architectures or configurations (e.g., nested interrupts) allow interrupts to preempt an ISR. For example: IRQF_DISABLED (now deprecated): Previously controlled whether interrupts were disabled during the ISR. Modern kernels typically disable interrupts for all IRQ handlers by default. Threaded interrupts (using IRQF_ONESHOT or IRQF_THREAD): The “top half” runs in a kernel thread with interrupts enabled. Key Takeaway:"><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-05-04T13:49:00+00:00"><meta property="article:modified_time" content="2025-05-04T13:49:00+00:00"><meta property="article:tag" content="OS/Interrupt"><meta name=twitter:card content="summary"><meta name=twitter:title content="Interrupt Questions"><meta name=twitter:description content="Q1: What happens if another interrupt occurs while a top half (ISR) is executing?
Answer:

By default, interrupts are disabled during the top half execution. When the CPU enters the ISR (via the IDT), it automatically clears the Interrupt Flag (IF) on x86 (using cli), preventing further interrupts until the ISR finishes.
Exception: Some architectures or configurations (e.g., nested interrupts) allow interrupts to preempt an ISR. For example:

IRQF_DISABLED (now deprecated): Previously controlled whether interrupts were disabled during the ISR. Modern kernels typically disable interrupts for all IRQ handlers by default.
Threaded interrupts (using IRQF_ONESHOT or IRQF_THREAD): The &ldquo;top half&rdquo; runs in a kernel thread with interrupts enabled.



Key Takeaway:"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://rishav-singh-0.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Interrupt Questions","item":"https://rishav-singh-0.github.io/posts/interrupt-questions/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Interrupt Questions","name":"Interrupt Questions","description":"Q1: What happens if another interrupt occurs while a top half (ISR) is executing? Answer:\nBy default, interrupts are disabled during the top half execution. When the CPU enters the ISR (via the IDT), it automatically clears the Interrupt Flag (IF) on x86 (using cli), preventing further interrupts until the ISR finishes. Exception: Some architectures or configurations (e.g., nested interrupts) allow interrupts to preempt an ISR. For example: IRQF_DISABLED (now deprecated): Previously controlled whether interrupts were disabled during the ISR. Modern kernels typically disable interrupts for all IRQ handlers by default. Threaded interrupts (using IRQF_ONESHOT or IRQF_THREAD): The \u0026ldquo;top half\u0026rdquo; runs in a kernel thread with interrupts enabled. Key Takeaway:\n","keywords":["OS/Interrupt"],"articleBody":"Q1: What happens if another interrupt occurs while a top half (ISR) is executing? Answer:\nBy default, interrupts are disabled during the top half execution. When the CPU enters the ISR (via the IDT), it automatically clears the Interrupt Flag (IF) on x86 (using cli), preventing further interrupts until the ISR finishes. Exception: Some architectures or configurations (e.g., nested interrupts) allow interrupts to preempt an ISR. For example: IRQF_DISABLED (now deprecated): Previously controlled whether interrupts were disabled during the ISR. Modern kernels typically disable interrupts for all IRQ handlers by default. Threaded interrupts (using IRQF_ONESHOT or IRQF_THREAD): The “top half” runs in a kernel thread with interrupts enabled. Key Takeaway:\nMost ISRs run with interrupts disabled, ensuring atomicity. If a nested interrupt occurs (rare), it will be queued and handled after the current ISR completes. Q2: How does the kernel prevent stack overflow due to nested interrupts? Answer:\nEach CPU has separate stacks for different contexts: Hardware Interrupt Stack: A small, fixed-size per-CPU stack (e.g., 4KB–16KB). Process Stack: Used when executing in process context. Nesting Depth: The kernel limits interrupt nesting (e.g., x86 allows limited depth before a double fault is triggered). Example:\nIf an ISR for IRQ 1 (keyboard) is interrupted by IRQ 12 (mouse), the CPU switches to the interrupt stack. If nesting exceeds the stack size, the kernel panics with a stack overflow.\nQ3: What happens if two devices share the same IRQ line? Answer:\nShared IRQs: Drivers can register handlers with IRQF_SHARED in request_irq(). During ISR execution, the kernel calls all registered handlers for that IRQ. Each handler checks if its device triggered the interrupt (e.g., by reading a device status register). The first handler that acknowledges the interrupt (returns IRQ_HANDLED) stops further propagation. Example:\n// Driver 1 (Shared IRQ 9) request_irq(9, my_isr1, IRQF_SHARED, \"dev1\", \u0026dev1); // Driver 2 (Shared IRQ 9) request_irq(9, my_isr2, IRQF_SHARED, \"dev2\", \u0026dev2); In my_isr1, the driver reads a hardware register to confirm the interrupt was from dev1. If not, it returns IRQ_NONE, allowing my_isr2 to run.\nQ4: Can the same IRQ be handled concurrently on different CPUs? Answer:\nYes, if the interrupt is not marked as per-CPU (IRQF_PERCPU). The kernel allows an IRQ to be handled on any CPU unless restricted. Race Conditions: Shared data between CPUs requires synchronization (e.g., spinlocks with spin_lock_irqsave()). Best Practice:\nUse IRQF_PERCPU for interrupts that are inherently CPU-local (e.g., APIC timer interrupts).\nQ5: What happens if you call a blocking function (e.g., sleep()) in the top half? Answer:\nNever do this! The top half runs in atomic context (interrupts disabled, no process context). Blocking functions like sleep(), kmalloc(GFP_KERNEL), or mutexes will cause a kernel panic or deadlock. Safe Functions:\nUse kmalloc(GFP_ATOMIC) for memory allocation. Use spinlocks instead of mutexes. Interview Tip:\nIf asked how to debug a hung system, suspect a blocking call in an ISR. Tools like kgdb or analyzing crash dumps can help.\nQ6: How does the kernel ensure the top half is minimal? Answer:\nDesign Principle: The top half only does time-critical work (e.g., acknowledging the interrupt, reading hardware status). All other processing is deferred to the bottom half (tasklets, softirqs, workqueues). Kernel Enforcement: No explicit enforcement, but violating this principle causes performance issues (e.g., high interrupt latency). Example:\nA network driver’s top half copies a packet from the device to a buffer and schedules a softirq (NET_RX_SOFTIRQ) for further processing.\nQ7: How to handle reentrancy in the top half? Answer:\nReentrancy: If the same IRQ can interrupt its own handler (e.g., nested interrupts), use reentrancy-safe techniques: Disable interrupts locally: Use local_irq_save(flags) to manually disable interrupts. Per-CPU Data: Use get_cpu_var() to access CPU-local variables. Example:\nirqreturn_t my_isr(int irq, void *dev_id) { unsigned long flags; local_irq_save(flags); // Disable interrupts // Critical section local_irq_restore(flags); // Re-enable return IRQ_HANDLED; } Q8: How to measure the latency of a top half? Answer:\nTools: ftrace with irqsoff tracer to measure time interrupts are disabled. perf to profile ISR execution time. Metric: Aim for top-half execution time in microseconds. Command:\necho irqsoff \u003e /sys/kernel/debug/tracing/current_tracer cat /sys/kernel/debug/tracing/trace Q9: What is the difference between IRQF_SHARED and IRQF_PERCPU? Answer:\nIRQF_SHARED: Allows multiple devices to share the same IRQ line (e.g., PCI devices) IRQF_PERCPU: The IRQ is mapped to a specific CPU (e.g., timer interrupts) Use Case:\nUse IRQF_SHARED for devices like USB controllers. Use IRQF_PERCPU for CPU-local events (e.g., APIC timer). Q10: How to safely exit a top half if the interrupt wasn’t for your device? Answer:\nReturn IRQ_NONE in the ISR. This tells the kernel to continue probing other handlers for the shared IRQ. Example:\nirqreturn_t my_isr(int irq, void *dev_id) { if (!check_device_status(dev_id)) // Not our interrupt return IRQ_NONE; // Process interrupt return IRQ_HANDLED; } Key Takeaways for Interviews: Atomicity: Top halves run with interrupts disabled. No Blocking: Never call sleeping functions. Defer Work: Use bottom halves for non-urgent tasks. Concurrency: Shared IRQs require reentrancy checks. Debugging: Tools like ftrace and perf are essential. ","wordCount":"813","inLanguage":"en","datePublished":"2025-05-04T13:49:00Z","dateModified":"2025-05-04T13:49:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://rishav-singh-0.github.io/posts/interrupt-questions/"},"publisher":{"@type":"Organization","name":"Rishav's Digital Garden","logo":{"@type":"ImageObject","url":"https://rishav-singh-0.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://rishav-singh-0.github.io/ accesskey=h title="Rishav's Digital Garden (Alt + H)">Rishav's Digital Garden</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://rishav-singh-0.github.io/archives title=Archive><span>Archive</span></a></li><li><a href=https://rishav-singh-0.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://rishav-singh-0.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Interrupt Questions</h1><div class=post-meta><span title='2025-05-04 13:49:00 +0000 UTC'>May 4, 2025</span>&nbsp;·&nbsp;4 min</div></header><div class=post-content><h3 id=q1-what-happens-if-another-interrupt-occurs-while-a-top-half-isr-is-executing>Q1: What happens if another interrupt occurs while a top half (ISR) is executing?<a hidden class=anchor aria-hidden=true href=#q1-what-happens-if-another-interrupt-occurs-while-a-top-half-isr-is-executing>#</a></h3><p><strong>Answer</strong>:</p><ul><li>By default, <strong>interrupts are disabled</strong> during the top half execution. When the CPU enters the ISR (via the IDT), it automatically clears the <strong>Interrupt Flag (IF)</strong> on x86 (using <code>cli</code>), preventing further interrupts until the ISR finishes.</li><li><strong>Exception</strong>: Some architectures or configurations (e.g., <strong>nested interrupts</strong>) allow interrupts to preempt an ISR. For example:<ul><li><strong>IRQF_DISABLED</strong> (now deprecated): Previously controlled whether interrupts were disabled during the ISR. Modern kernels typically disable interrupts for all IRQ handlers by default.</li><li><strong>Threaded interrupts</strong> (using <code>IRQF_ONESHOT</code> or <code>IRQF_THREAD</code>): The &ldquo;top half&rdquo; runs in a kernel thread with interrupts enabled.</li></ul></li></ul><p><strong>Key Takeaway</strong>:</p><ul><li>Most ISRs run with interrupts disabled, ensuring atomicity. If a nested interrupt occurs (rare), it will be queued and handled after the current ISR completes.</li></ul><hr><h3 id=q2-how-does-the-kernel-prevent-stack-overflow-due-to-nested-interrupts>Q2: How does the kernel prevent stack overflow due to nested interrupts?<a hidden class=anchor aria-hidden=true href=#q2-how-does-the-kernel-prevent-stack-overflow-due-to-nested-interrupts>#</a></h3><p><strong>Answer</strong>:</p><ul><li>Each CPU has <strong>separate stacks for different contexts</strong>:<ul><li><strong>Hardware Interrupt Stack</strong>: A small, fixed-size per-CPU stack (e.g., 4KB–16KB).</li><li><strong>Process Stack</strong>: Used when executing in process context.</li></ul></li><li><strong>Nesting Depth</strong>: The kernel limits interrupt nesting (e.g., x86 allows limited depth before a <strong>double fault</strong> is triggered).</li></ul><p><strong>Example</strong>:<br>If an ISR for IRQ 1 (keyboard) is interrupted by IRQ 12 (mouse), the CPU switches to the interrupt stack. If nesting exceeds the stack size, the kernel panics with a stack overflow.</p><hr><h3 id=q3-what-happens-if-two-devices-share-the-same-irq-line>Q3: What happens if two devices share the same IRQ line?<a hidden class=anchor aria-hidden=true href=#q3-what-happens-if-two-devices-share-the-same-irq-line>#</a></h3><p><strong>Answer</strong>:</p><ul><li><strong>Shared IRQs</strong>: Drivers can register handlers with <code>IRQF_SHARED</code> in <code>request_irq()</code>.</li><li>During ISR execution, the kernel calls <strong>all registered handlers</strong> for that IRQ. Each handler checks if its device triggered the interrupt (e.g., by reading a device status register).</li><li>The first handler that acknowledges the interrupt (returns <code>IRQ_HANDLED</code>) stops further propagation.</li></ul><p><strong>Example</strong>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>// Driver 1 (Shared IRQ 9)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>request_irq</span>(<span style=color:#ae81ff>9</span>, my_isr1, IRQF_SHARED, <span style=color:#e6db74>&#34;dev1&#34;</span>, <span style=color:#f92672>&amp;</span>dev1);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Driver 2 (Shared IRQ 9)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>request_irq</span>(<span style=color:#ae81ff>9</span>, my_isr2, IRQF_SHARED, <span style=color:#e6db74>&#34;dev2&#34;</span>, <span style=color:#f92672>&amp;</span>dev2);
</span></span></code></pre></div><p>In <code>my_isr1</code>, the driver reads a hardware register to confirm the interrupt was from <code>dev1</code>. If not, it returns <code>IRQ_NONE</code>, allowing <code>my_isr2</code> to run.</p><hr><h3 id=q4-can-the-same-irq-be-handled-concurrently-on-different-cpus>Q4: Can the same IRQ be handled concurrently on different CPUs?<a hidden class=anchor aria-hidden=true href=#q4-can-the-same-irq-be-handled-concurrently-on-different-cpus>#</a></h3><p><strong>Answer</strong>:</p><ul><li><strong>Yes</strong>, if the interrupt is <strong>not marked as per-CPU</strong> (<code>IRQF_PERCPU</code>). The kernel allows an IRQ to be handled on any CPU unless restricted.</li><li><strong>Race Conditions</strong>: Shared data between CPUs requires synchronization (e.g., spinlocks with <code>spin_lock_irqsave()</code>).</li></ul><p><strong>Best Practice</strong>:<br>Use <code>IRQF_PERCPU</code> for interrupts that are inherently CPU-local (e.g., APIC timer interrupts).</p><hr><h3 id=q5-what-happens-if-you-call-a-blocking-function-eg-sleep-in-the-top-half>Q5: What happens if you call a blocking function (e.g., <code>sleep()</code>) in the top half?<a hidden class=anchor aria-hidden=true href=#q5-what-happens-if-you-call-a-blocking-function-eg-sleep-in-the-top-half>#</a></h3><p><strong>Answer</strong>:</p><ul><li><strong>Never do this!</strong> The top half runs in <strong>atomic context</strong> (interrupts disabled, no process context). Blocking functions like <code>sleep()</code>, <code>kmalloc(GFP_KERNEL)</code>, or mutexes will cause a kernel panic or deadlock.</li></ul><p><strong>Safe Functions</strong>:</p><ul><li>Use <code>kmalloc(GFP_ATOMIC)</code> for memory allocation.</li><li>Use spinlocks instead of mutexes.</li></ul><p><strong>Interview Tip</strong>:<br>If asked how to debug a hung system, suspect a blocking call in an ISR. Tools like <code>kgdb</code> or analyzing crash dumps can help.</p><hr><h3 id=q6-how-does-the-kernel-ensure-the-top-half-is-minimal>Q6: How does the kernel ensure the top half is minimal?<a hidden class=anchor aria-hidden=true href=#q6-how-does-the-kernel-ensure-the-top-half-is-minimal>#</a></h3><p><strong>Answer</strong>:</p><ul><li><strong>Design Principle</strong>: The top half only does <strong>time-critical work</strong> (e.g., acknowledging the interrupt, reading hardware status). All other processing is deferred to the <strong>bottom half</strong> (tasklets, softirqs, workqueues).</li><li><strong>Kernel Enforcement</strong>: No explicit enforcement, but violating this principle causes performance issues (e.g., high interrupt latency).</li></ul><p><strong>Example</strong>:<br>A network driver&rsquo;s top half copies a packet from the device to a buffer and schedules a softirq (<code>NET_RX_SOFTIRQ</code>) for further processing.</p><hr><h3 id=q7-how-to-handle-reentrancy-in-the-top-half>Q7: How to handle reentrancy in the top half?<a hidden class=anchor aria-hidden=true href=#q7-how-to-handle-reentrancy-in-the-top-half>#</a></h3><p><strong>Answer</strong>:</p><ul><li><strong>Reentrancy</strong>: If the same IRQ can interrupt its own handler (e.g., nested interrupts), use reentrancy-safe techniques:<ol><li><strong>Disable interrupts locally</strong>: Use <code>local_irq_save(flags)</code> to manually disable interrupts.</li><li><strong>Per-CPU Data</strong>: Use <code>get_cpu_var()</code> to access CPU-local variables.</li></ol></li></ul><p><strong>Example</strong>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>irqreturn_t</span> <span style=color:#a6e22e>my_isr</span>(<span style=color:#66d9ef>int</span> irq, <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>dev_id) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> flags;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>local_irq_save</span>(flags); <span style=color:#75715e>// Disable interrupts
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// Critical section
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>local_irq_restore</span>(flags); <span style=color:#75715e>// Re-enable
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> IRQ_HANDLED;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><hr><h3 id=q8-how-to-measure-the-latency-of-a-top-half>Q8: How to measure the latency of a top half?<a hidden class=anchor aria-hidden=true href=#q8-how-to-measure-the-latency-of-a-top-half>#</a></h3><p><strong>Answer</strong>:</p><ul><li><strong>Tools</strong>:<ul><li><code>ftrace</code> with <code>irqsoff</code> tracer to measure time interrupts are disabled.</li><li><code>perf</code> to profile ISR execution time.</li></ul></li><li><strong>Metric</strong>: Aim for top-half execution time in <strong>microseconds</strong>.</li></ul><p><strong>Command</strong>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>echo irqsoff &gt; /sys/kernel/debug/tracing/current_tracer
</span></span><span style=display:flex><span>cat /sys/kernel/debug/tracing/trace
</span></span></code></pre></div><hr><h3 id=q9-what-is-the-difference-between-irqf_shared-and-irqf_percpu>Q9: What is the difference between <code>IRQF_SHARED</code> and <code>IRQF_PERCPU</code>?<a hidden class=anchor aria-hidden=true href=#q9-what-is-the-difference-between-irqf_shared-and-irqf_percpu>#</a></h3><p><strong>Answer</strong>:</p><ul><li><strong><code>IRQF_SHARED</code></strong>: Allows multiple devices to share the same IRQ line (e.g., PCI devices)</li><li><strong><code>IRQF_PERCPU</code></strong>: The IRQ is mapped to a specific CPU (e.g., timer interrupts)</li></ul><p><strong>Use Case</strong>:</p><ul><li>Use <code>IRQF_SHARED</code> for devices like USB controllers.</li><li>Use <code>IRQF_PERCPU</code> for CPU-local events (e.g., APIC timer).</li></ul><hr><h3 id=q10-how-to-safely-exit-a-top-half-if-the-interrupt-wasnt-for-your-device>Q10: How to safely exit a top half if the interrupt wasn’t for your device?<a hidden class=anchor aria-hidden=true href=#q10-how-to-safely-exit-a-top-half-if-the-interrupt-wasnt-for-your-device>#</a></h3><p><strong>Answer</strong>:</p><ul><li>Return <code>IRQ_NONE</code> in the ISR. This tells the kernel to continue probing other handlers for the shared IRQ.</li></ul><p><strong>Example</strong>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>irqreturn_t</span> <span style=color:#a6e22e>my_isr</span>(<span style=color:#66d9ef>int</span> irq, <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>dev_id) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span><span style=color:#a6e22e>check_device_status</span>(dev_id)) <span style=color:#75715e>// Not our interrupt
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>return</span> IRQ_NONE;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Process interrupt
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> IRQ_HANDLED;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><hr><h3 id=key-takeaways-for-interviews>Key Takeaways for Interviews:<a hidden class=anchor aria-hidden=true href=#key-takeaways-for-interviews>#</a></h3><ol><li><strong>Atomicity</strong>: Top halves run with interrupts disabled.</li><li><strong>No Blocking</strong>: Never call sleeping functions.</li><li><strong>Defer Work</strong>: Use bottom halves for non-urgent tasks.</li><li><strong>Concurrency</strong>: Shared IRQs require reentrancy checks.</li><li><strong>Debugging</strong>: Tools like <code>ftrace</code> and <code>perf</code> are essential.</li></ol></div><footer class=post-footer><ul class=post-tags><li><a href=https://rishav-singh-0.github.io/tags/os/interrupt/>OS/Interrupt</a></li></ul><nav class=paginav><a class=prev href=https://rishav-singh-0.github.io/posts/interrupt-handling-flow/><span class=title>« Prev</span><br><span>Interrupt Handling Flow</span>
</a><a class=next href=https://rishav-singh-0.github.io/posts/interrupt/><span class=title>Next »</span><br><span>Interrupt</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://rishav-singh-0.github.io/>Rishav's Digital Garden</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>