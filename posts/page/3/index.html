<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | Rishav's Digital Garden</title>
<meta name=keywords content><meta name=description content="Posts - Rishav's Digital Garden"><meta name=author content><link rel=canonical href=https://blog.rishavs.in/posts/><link crossorigin=anonymous href=/assets/css/stylesheet.2211ca3164be7830024f6aad2b3a2e520843a64f8f048445c3401c1249aa051d.css integrity="sha256-IhHKMWS+eDACT2qtKzouUghDpk+PBIRFw0AcEkmqBR0=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.rishavs.in/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.rishavs.in/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.rishavs.in/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.rishavs.in/apple-touch-icon.png><link rel=mask-icon href=https://blog.rishavs.in/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://blog.rishavs.in/posts/index.xml><link rel=alternate hreflang=en href=https://blog.rishavs.in/posts/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://blog.rishavs.in/posts/"><meta property="og:site_name" content="Rishav's Digital Garden"><meta property="og:title" content="Posts"><meta property="og:locale" content="en-us"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Posts"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.rishavs.in/posts/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.rishavs.in/ accesskey=h title="Rishav's Digital Garden (Alt + H)">Rishav's Digital Garden</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.rishavs.in/archives title=Archive><span>Archive</span></a></li><li><a href=https://blog.rishavs.in/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://blog.rishavs.in/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><header class=page-header><h1>Posts</h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Kernel Space vs User Space</h2></header><div class=entry-content><p>Overview Kernel Space: This is where the Linux kernel executes and provides low-level access to hardware, system memory management, process scheduling, and device drivers. Kernel space has privileged access to system resources and is protected from direct user interference. For example, when a user requests data from a hardware sensor, the kernel driver handles communication with the hardware, processes the request, and returns the data to user space through system calls. User Space: This is where applications and system utilities run. User-space processes operate with restricted privileges and interact with the kernel via system calls, libraries, and IPC mechanisms. For example, a user-space daemon may monitor the watchdog status by writing to /dev/watchdog, or a mobile app may read light intensity from /sys/bus/i2c/devices/1-0039/lux. Communication Methods between Kernel and User Space There are several ways to facilitate communication between user space and kernel space in an embedded Linux environment:
...</p></div><footer class=entry-footer><span title='2025-02-04 17:23:00 +0000 UTC'>February 4, 2025</span>&nbsp;·&nbsp;3 min</footer><a class=entry-link aria-label="post link to Kernel Space vs User Space" href=https://blog.rishavs.in/posts/kernel-space-vs-user-space/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>RTOS (FreeRTOS) vs Linux Kernel</h2></header><div class=entry-content><p>1. Overview RTOS (Real-Time Operating System): Designed for deterministic, time-critical applications with low-latency response. Why RTOS over Linux? Deterministic Execution: RTOS ensures tasks meet strict timing deadlines, unlike Linux, which has non-deterministic scheduling. Low Overhead: RTOS has minimal context switching overhead and no user/kernel space separation. Resource-Constrained Devices: Ideal for microcontrollers (MCUs) with limited memory and processing power. Fast Boot Times: RTOS boots in milliseconds, while Linux requires a much longer initialization process. Interrupt Handling: More responsive to real-time interrupts, whereas Linux introduces latency due to its complex scheduler. FreeRTOS: A lightweight, open-source RTOS widely used in embedded systems. Linux Kernel: A general-purpose OS with multi-user capabilities, used in complex embedded and desktop/server systems. 2. FreeRTOS vs. Linux Kernel (Key Differences) Kernel vs. User Space FreeRTOS: It doesn’t have the concept of a user space and kernel space like Linux. The whole system is essentially one space, and tasks directly interact with the kernel (RTOS). You can think of FreeRTOS as a single program running with different tasks that can interact with each other or with hardware directly. Linux Kernel: Linux operates with a strict separation between user space and kernel space. User applications cannot directly interact with hardware; they must go through system calls, which are handled by the kernel. Scheduler FreeRTOS: Preemptive, cooperative, or tickless scheduling. Supports priority-based scheduling (fixed priority, round-robin, etc.). Simple task model, each task runs in its own stack but shares memory. Linux Kernel Also has a preemptive scheduler, but it is much more complex, as it must handle multiple users, system calls, different types of scheduling (e.g., real-time, normal tasks), and various priorities. Linux is optimized for fairness CFS (Completely Fair Scheduler) and general-purpose multitasking. The FreeRTOS scheduler, by contrast, is simpler and more deterministic. Processes FreeRTOS: Does not have a “process” model like Linux. Instead, it has tasks. Tasks in FreeRTOS can be thought of as lightweight threads. FreeRTOS doesn’t manage the memory space for each task in the same way Linux does for processes. All tasks share the same address space and run in the same context. Linux Kernel: Linux uses processes, each of which has its own memory space. Processes in Linux can be multi-threaded, and each thread can have different scheduling characteristics. Linux processes are isolated from each other, so one process crashing doesn’t affect others. Memory Management FreeRTOS: Memory management is more manual. FreeRTOS does not have sophisticated memory management like Linux. It provides basic functions for allocating fixed-size blocks or dynamic memory pools (pvPortMalloc, vPortFree). It doesn’t have virtual memory, so all tasks have access to the same memory space, making it much simpler but also more prone to memory corruption if not managed properly. Linux Kernel: Linux includes virtual memory, meaning each process has its own virtual address space. It supports advanced features like paging and memory protection. The Linux kernel has a memory management unit (MMU) and sophisticated memory allocators for heap, stack, and memory mapping. Drivers FreeRTOS: Drivers in FreeRTOS are usually written to interface directly with the hardware. Embedded developers write hardware-specific drivers for devices such as GPIO, UART, SPI, I2C, etc. The drivers are tightly coupled with the hardware and typically run in the same task context as the rest of the application. Interfacing with hardware is done via direct memory-mapped registers and interrupt service routines (ISRs). Linux Kernel: The Linux kernel has a comprehensive set of device drivers for a wide variety of hardware. Drivers in Linux are implemented as kernel modules, which can be dynamically loaded and unloaded. These drivers abstract hardware interactions and often provide a system call interface for user-space applications to interact with hardware. GPIO Management FreeRTOS: Direct register manipulation or vendor-specific HAL libraries. No standard GPIO subsystem like Linux. GPIO interrupts are handled using ISR (Interrupt Service Routines) with FreeRTOS primitives like queues for event notification. Linux Kernel: GPIO Subsystem: Provides an abstraction layer using sysfs, character devices, or device tree bindings. Uses kernel interrupt handling with debounce and polling mechanisms. Interrupt Handling FreeRTOS: Interrupt handling is done through Interrupt Service Routines (ISRs), which are small, time-critical functions that handle hardware interrupts. FreeRTOS provides mechanisms to synchronize tasks with ISRs via semaphores or queues. Linux Kernel: Linux also uses ISRs, but in addition to regular interrupts, it has a more complex mechanism for handling asynchronous events, such as software interrupts, tasklets, work queues, etc. The kernel abstracts much of the interrupt management for portability. Synchronization Mechanisms FreeRTOS: Offers simple synchronization primitives like semaphores, mutexes, queues, and event groups. These are lightweight and highly optimized for small systems with limited resources. Linux Kernel: Linux also provides synchronization mechanisms like semaphores, mutexes, and spinlocks. However, these mechanisms are more complex and support features like priority inversion prevention, as well as various types of locking for different kernel contexts. Filesystem and I/O FreeRTOS: By default, FreeRTOS does not provide any filesystem management or complex I/O subsystem. I/O is typically done through simple APIs provided by the BSP or device driver code. Linux Kernel: Linux supports a full-fledged filesystem with many types (e.g., ext4, NTFS) and includes complex device I/O management, including file descriptors, blocking/non-blocking I/O, and extensive support for network file systems (NFS, CIFS). Conclusion: Feature FreeRTOS Linux Kernel Kernel/User Space Single space Separated Scheduler Priority-based, Preemptive CFS, RT scheduling Driver Model Direct access, HAL-based Kernel module-based GPIO Management Direct register access Standard GPIO subsystem Process Model Tasks only Processes & Threads Memory Management Heap-based, no MMU Virtual memory, MMU support Use Cases Real-time, MCUs High-performance, SBCs, SoCs FreeRTOS and Linux serve different purposes in embedded systems:
...</p></div><footer class=entry-footer><span title='2025-02-04 13:59:00 +0000 UTC'>February 4, 2025</span>&nbsp;·&nbsp;5 min</footer><a class=entry-link aria-label="post link to RTOS (FreeRTOS) vs Linux Kernel" href=https://blog.rishavs.in/posts/rtos-freertos-vs-linux-kernel/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>BSP Topics</h2></header><div class=entry-content><p>1. Linux Kernel Internals Importance: Understanding kernel internals is crucial for BSP and driver development as it helps in debugging, optimizing performance, and modifying the kernel to meet hardware-specific requirements.
Topics: Kernel Architecture: [Monolithic vs Microkernel]({&lt; ref “/posts/monolithic-vs-microkernel/” >}}), [Kernel Space vs User Space|Kernel and User Space interactions]({&lt; ref “/posts/kernel-space-vs-user-space|kernel-and-user-space-interactions/” >}}). Process Management: Understanding task_struct, process states, scheduling algorithms. Interrupt Handling: SoftIRQs, tasklets, bottom halves, handling IRQs efficiently. Memory Management: Paging, kmalloc/vmalloc, slab allocator, ARM MMU and memory regions. [../../0-Inbox/syscalls|Syscalls]({&lt; ref “/posts/../../0-inbox/syscalls|syscalls/” >}}): How system calls work, writing custom syscalls. [Kernel Synchronization in Linux|Kernel Synchronization]({&lt; ref “/posts/kernel-synchronization-in-linux|kernel-synchronization/” >}}): Spinlocks, mutexes, semaphores, barriers, RCU. Workqueues and Timers: Deferred execution, using timers for scheduling tasks. 2. Linux Device Drivers Importance: Device drivers are the bridge between hardware and the OS. Understanding drivers is crucial for embedded systems and BSP development.
...</p></div><footer class=entry-footer><span title='2025-02-04 10:39:00 +0000 UTC'>February 4, 2025</span>&nbsp;·&nbsp;4 min</footer><a class=entry-link aria-label="post link to BSP Topics" href=https://blog.rishavs.in/posts/bsp-topics/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>GitFlow</h2></header><div class=entry-content><p>![Pasted image 20250203182747](./Pasted image 20250203182747.png)
Reference GirFlow Explained: https://youtu.be/Aa8RpP0sf-Y</p></div><footer class=entry-footer><span title='2025-02-03 16:37:00 +0000 UTC'>February 3, 2025</span>&nbsp;·&nbsp;1 min</footer><a class=entry-link aria-label="post link to GitFlow" href=https://blog.rishavs.in/posts/gitflow/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>SHA-256 (Secure Hash Algorithm 256-bit)</h2></header><div class=entry-content><p>SHA-256 is a cryptographic hash function that produces a fixed-size 256-bit (32-byte) hash. It is deterministic, collision-resistant, and designed for security-critical applications.
How SHA-256 Works Preprocessing: Pad the input to a multiple of 512 bits. Append a 1, then add k zeros, and finally append the original message length (64 bits). Initialize Hash Values: Use constants derived from the fractional parts of square roots of the first 8 primes (eight 32-bit words). Example: h0 = 0x6a09e667, h1 = 0xbb67ae85, .... Process Blocks: Split the padded message into 512-bit blocks. For each block: Expand the block into 64 words using a message schedule. Perform 64 rounds of compression using bitwise operations (e.g., XOR, AND, modular addition). Compression Function A compression function is applied to each block, creating a new hash value. This function involves mixing the bits of the current hash value and the message block. Iteration Repeat the compression function for each block, using the output of each iteration as input for the next. Final Hash: Combine the intermediate hash values to produce the final 256-bit digest. Example: SHA-256 for String “Hello” Input: “Hello” → ASCII 48656C6C6F. Padding: Length = 40 bits (5 bytes). Pad with 1, 407 zeros, and 0000000000000028 (hex for 40 bits). Hash Computation: After processing, the final hash is: 185f8db32271fe25f561a6fc938b2e264306ec304eda518007d1764826381969. Use Cases SHA-256 Cryptographic security in: Digital signatures (SSL/TLS certificates). Password storage (hashed+salted). Blockchain (Bitcoin transactions). File integrity verification (e.g., software downloads). Guarantees: Pre-image resistance, collision resistance.</p></div><footer class=entry-footer><span title='2025-01-29 14:12:00 +0000 UTC'>January 29, 2025</span>&nbsp;·&nbsp;2 min</footer><a class=entry-link aria-label="post link to SHA-256 (Secure Hash Algorithm 256-bit)" href=https://blog.rishavs.in/posts/sha-256-secure-hash-algorithm-256-bit/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>CRC (Cyclic Redundancy Check)</h2></header><div class=entry-content><p>CRC is an error-detection code used to detect accidental changes to raw data (e.g., during transmission or storage). It works by treating the data as a polynomial and performing polynomial division with a predefined generator polynomial. The remainder of this division becomes the CRC value.
How CRC is Calculated Convert data to binary: Treat the data as a sequence of bits. Append zeros: Add n zeros to the end of the data, where n is the degree of the generator polynomial (e.g., CRC-32 uses a 33-bit polynomial, so append 32 zeros). Polynomial division: Divide the data + zeros by the generator polynomial using modulo-2 arithmetic (XOR operations). CRC value: The remainder of this division is the CRC checksum. Example: CRC-8 for String “Hi” Data: “Hi” in ASCII is 01001000 01101001. Generator Polynomial: CRC-8 (e.g., x⁸ + x² + x + 1), represented as 100000111. Append 8 zeros:
Data becomes 010010000110100100000000. Perform division: Divide 010010000110100100000000 by 100000111 using XOR. Remainder: Let’s assume the remainder is 00110110 (hex 0x36). Final CRC: 0x36. Use Cases Error detection in: Network protocols (Ethernet, Wi-Fi). Storage systems (hard drives, ZIP files). Quick checksums for small data transfers. Not secure against intentional tampering.</p></div><footer class=entry-footer><span title='2025-01-29 14:09:00 +0000 UTC'>January 29, 2025</span>&nbsp;·&nbsp;1 min</footer><a class=entry-link aria-label="post link to CRC (Cyclic Redundancy Check)" href=https://blog.rishavs.in/posts/crc-cyclic-redundancy-check/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Device Tree (DT) in Linux Kernel</h2></header><div class=entry-content><p>Overview The Device Tree (DT) is a data structure used to describe the hardware components of a system in a way that is independent of the operating system and software. It is particularly relevant for systems based on the ARM architecture, where the hardware varies significantly across devices.
Instead of hardcoding hardware details in the kernel, the device tree provides a flexible way to inform the kernel about the system’s hardware layout. This simplifies kernel code and enables easier reuse across multiple hardware platforms.
...</p></div><footer class=entry-footer><span title='2025-01-27 17:41:00 +0000 UTC'>January 27, 2025</span>&nbsp;·&nbsp;5 min</footer><a class=entry-link aria-label="post link to Device Tree (DT) in Linux Kernel" href=https://blog.rishavs.in/posts/device-tree-dt-in-linux-kernel/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Character Device Management in Kernel Drivers</h2></header><div class=entry-content><p>Overview Character devices allow byte-by-byte communication between user-space applications and kernel drivers. They are commonly used for devices like serial ports, sensors, and custom hardware interfaces. The Linux kernel provides mechanisms for registering, managing, and interacting with character devices via a device file in /dev.
Registering a Character Device To register a character device, the driver needs to:
1. Allocate a Major and Minor Number: Each character device is identified by a major number (device type) and a minor number (specific device). The major number indicates the driver associated with the device, while the minor number is used to differentiate between multiple devices handled by the same driver. If major and minor numbers are repeated, it can cause conflicts and lead to incorrect device identification. To avoid this, the kernel provides alloc_chrdev_region, a function to dynamically allocate major and minor numbers, ensuring uniqueness. These numbers are used in the /dev directory to associate device files with their corresponding drivers. Use alloc_chrdev_region to dynamically allocate a major number. dev_t dev; int result; // kernel/fs/char_dev.c // int alloc_chrdev_region(dev_t *dev, unsigned baseminor, unsigned count, const char *name) result = alloc_chrdev_region(&amp;dev, 0, 1, "my_char_device"); if (result &lt; 0) { pr_err("Failed to allocate major number\n"); return result; } pr_info("Device registered with major %d, minor %d\n", MAJOR(dev), MINOR(dev)); 2. Initialize and Register the Device: Define a cdev structure and initialize it with file operations. Use cdev_add to register the device with the kernel. struct cdev my_cdev; cdev_init(&amp;my_cdev, &amp;my_fops); my_cdev.owner = THIS_MODULE; result = cdev_add(&amp;my_cdev, dev, 1); if (result &lt; 0) { pr_err("Failed to add cdev\n"); unregister_chrdev_region(dev, 1); return result; } 3. Create a Device File (Optional): Creating a device file in /dev is optional because character devices can be accessed directly using their major and minor numbers through system calls or user-space libraries, bypassing the need for a device file. However, creating a file in /dev makes interaction more user-friendly by providing a standard interface. To interact with a character device without creating a device file, you can use system calls like mknod to create a temporary device node or interact with the device directly using its major and minor numbers programmatically. Use class_create and device_create to automatically create a device file in /dev. struct class *my_class; my_class = class_create(THIS_MODULE, "my_device_class"); if (IS_ERR(my_class)) { pr_err("Failed to create class\n"); cdev_del(&amp;my_cdev); unregister_chrdev_region(dev, 1); return PTR_ERR(my_class); } device_create(my_class, NULL, dev, NULL, "my_char_device"); File Operations Character devices are controlled through a set of file operations defined in a struct file_operations. These operations determine how the device responds to system calls like open, read, write, and ioctl.
...</p></div><footer class=entry-footer><span title='2025-01-24 17:54:00 +0000 UTC'>January 24, 2025</span>&nbsp;·&nbsp;4 min</footer><a class=entry-link aria-label="post link to Character Device Management in Kernel Drivers" href=https://blog.rishavs.in/posts/character-device-management-in-kernel-drivers/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>IOCTL in Kernel Device Drivers</h2></header><div class=entry-content><p>ioctl Implementation in Kernel Device Drivers Overview ioctl (Input/Output Control) is a powerful system call in Linux used to perform device-specific operations that are not covered by standard system calls like read, write, or open. It allows user-space applications to interact with kernel-space drivers for device-specific configurations and data exchanges.
How ioctl Works 1. User-Space Interaction: A user-space application invokes ioctl using the following prototype: int ioctl(int fd, unsigned long cmd, void *arg); fd: File descriptor for the device. cmd: Command defining the operation. arg: Pointer to the data or argument passed between user-space and kernel-space. 2. Driver-Side Handling: The ioctl system call is routed to the driver by the kernel. The driver implements a specific unlocked_ioctl or compat_ioctl callback in the file_operations structure. 3. Data Flow: Arguments passed via arg can be pointers to user-space data, requiring the driver to use helper functions like copy_from_user and copy_to_user for secure data transfer. Steps to Implement ioctl in a Kernel Driver 1. Define ioctl Commands: Use macros to define command numbers, typically with the _IO, _IOR, _IOW, and _IOWR macros provided in &lt;linux/ioctl.h>. #define MY_IOCTL_BASE 'M' #define IOCTL_CMD_GET _IOR(MY_IOCTL_BASE, 1, int) #define IOCTL_CMD_SET _IOW(MY_IOCTL_BASE, 2, int) _IOR: Read data from the kernel. _IOW: Write data to the kernel. _IOWR: Read and write data. _IO: Command without data. 2. Implement ioctl Callback: Define the unlocked_ioctl function in the driver. Handle commands appropriately based on cmd. static long my_ioctl(struct file *file, unsigned int cmd, unsigned long arg) { int value; switch (cmd) { case IOCTL_CMD_GET: value = 1234; // Example value if (copy_to_user((int __user *)arg, &amp;value, sizeof(value))) return -EFAULT; break; case IOCTL_CMD_SET: if (copy_from_user(&amp;value, (int __user *)arg, sizeof(value))) return -EFAULT; pr_info("Value set by user: %d\n", value); break; default: return -ENOTTY; // Command not supported } return 0; } 3. Integrate into file_operations: Register the ioctl handler in the file_operations structure. static const struct file_operations my_fops = { .owner = THIS_MODULE, .open = my_open, .release = my_release, .unlocked_ioctl = my_ioctl, }; 4. Test the ioctl Implementation: Write a user-space application to interact with the driver. #include &lt;stdio.h> #include &lt;fcntl.h> #include &lt;unistd.h> #include &lt;sys/ioctl.h> #define MY_IOCTL_BASE 'M' #define IOCTL_CMD_GET _IOR(MY_IOCTL_BASE, 1, int) #define IOCTL_CMD_SET _IOW(MY_IOCTL_BASE, 2, int) int main() { int fd, value = 42; fd = open("/dev/my_device", O_RDWR); if (fd &lt; 0) { perror("Failed to open device"); return -1; } if (ioctl(fd, IOCTL_CMD_SET, &amp;value) &lt; 0) { perror("ioctl SET failed"); } if (ioctl(fd, IOCTL_CMD_GET, &amp;value) &lt; 0) { perror("ioctl GET failed"); } else { printf("Value from device: %d\n", value); } close(fd); return 0; } Best Practices for ioctl Use Explicit Command Definitions: Follow a consistent naming convention for command macros. Secure User-Kernel Data Transfer: Always validate pointers and sizes. Use copy_from_user and copy_to_user for safe data exchange. Error Handling: Return appropriate error codes for unsupported commands or invalid inputs. Limit ioctl Usage: Avoid using ioctl for operations that can be implemented using read or write. Magic Number: Ensure it’s unique (check Documentation/ioctl/ioctl-number.txt in kernel sources). Atomicity: Use locks if hardware operations are not atomic. Cross-Platform: Handle 32/64-bit compatibility with compat_ioctl if needed. Real-World Example: Custom ARM Board For a custom ARM board, you might need an ioctl to configure hardware parameters like GPIO modes or clock frequencies.
...</p></div><footer class=entry-footer><span title='2025-01-24 17:24:00 +0000 UTC'>January 24, 2025</span>&nbsp;·&nbsp;4 min</footer><a class=entry-link aria-label="post link to IOCTL in Kernel Device Drivers" href=https://blog.rishavs.in/posts/ioctl-in-kernel-device-drivers/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>SSL Certificate</h2></header><div class=entry-content><p>An SSL certificate is a digital certificate issued by a trusted third-party authority known as a Certificate Authority (CA). It verifies the identity of a website or server and enables secure, encrypted communication.
Components of an SSL Certificate Public Key: Used for encryption and verifying the certificate’s authenticity. Certificate Holder Information: Details like the domain name, organization, and location. Issuer Information: The CA that issued the certificate. Validity Period: Specifies the time frame during which the certificate is valid. Digital Signature: Ensures the certificate was issued by a trusted CA and has not been tampered with. Self-Signed Certificates Examples and Differences Type Usage Example Difference Self-Signed Internal servers, testing Generated via OpenSSL Not trusted by default in browsers or OS. CA-Signed Public-facing servers Issued by DigiCert, Let’s Encrypt Trusted by browsers and OS. Wildcard Certificate Secures a domain and its subdomains *.example.com Can’t be self-signed, requires a CA. Multi-Domain Certificate Covers multiple domains example.com, test.com Self-signed possible but not widely used. Self-Signed Certificates A self-signed certificate is a digital certificate that is not issued by a trusted Certificate Authority (CA) but is signed by the entity it is certifying (e.g., your own server). These certificates are primarily used for internal testing, development environments, or scenarios where external trust is not required.
...</p></div><footer class=entry-footer><span title='2024-12-10 18:05:00 +0000 UTC'>December 10, 2024</span>&nbsp;·&nbsp;3 min</footer><a class=entry-link aria-label="post link to SSL Certificate" href=https://blog.rishavs.in/posts/ssl-certificate/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://blog.rishavs.in/posts/page/2/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://blog.rishavs.in/posts/page/4/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://blog.rishavs.in/>Rishav's Digital Garden</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>