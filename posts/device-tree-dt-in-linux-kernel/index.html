<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Device Tree (DT) in Linux Kernel | Rishav's Digital Garden</title>
<meta name=keywords content="Platform/DeviceTree"><meta name=description content="Overview
The Device Tree (DT) is a data structure used to describe the hardware components of a system in a way that is independent of the operating system and software. It is particularly relevant for systems based on the ARM architecture, where the hardware varies significantly across devices.
Instead of hardcoding hardware details in the kernel, the device tree provides a flexible way to inform the kernel about the system&rsquo;s hardware layout. This simplifies kernel code and enables easier reuse across multiple hardware platforms."><meta name=author content><link rel=canonical href=https://rishav-singh-0.github.io/posts/device-tree-dt-in-linux-kernel/><link crossorigin=anonymous href=/assets/css/stylesheet.2211ca3164be7830024f6aad2b3a2e520843a64f8f048445c3401c1249aa051d.css integrity="sha256-IhHKMWS+eDACT2qtKzouUghDpk+PBIRFw0AcEkmqBR0=" rel="preload stylesheet" as=style><link rel=icon href=https://rishav-singh-0.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://rishav-singh-0.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://rishav-singh-0.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://rishav-singh-0.github.io/apple-touch-icon.png><link rel=mask-icon href=https://rishav-singh-0.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://rishav-singh-0.github.io/posts/device-tree-dt-in-linux-kernel/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://rishav-singh-0.github.io/posts/device-tree-dt-in-linux-kernel/"><meta property="og:site_name" content="Rishav's Digital Garden"><meta property="og:title" content="Device Tree (DT) in Linux Kernel"><meta property="og:description" content="Overview The Device Tree (DT) is a data structure used to describe the hardware components of a system in a way that is independent of the operating system and software. It is particularly relevant for systems based on the ARM architecture, where the hardware varies significantly across devices.
Instead of hardcoding hardware details in the kernel, the device tree provides a flexible way to inform the kernel about the system’s hardware layout. This simplifies kernel code and enables easier reuse across multiple hardware platforms."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-01-27T17:41:00+00:00"><meta property="article:modified_time" content="2025-01-27T17:41:00+00:00"><meta property="article:tag" content="Platform/DeviceTree"><meta name=twitter:card content="summary"><meta name=twitter:title content="Device Tree (DT) in Linux Kernel"><meta name=twitter:description content="Overview
The Device Tree (DT) is a data structure used to describe the hardware components of a system in a way that is independent of the operating system and software. It is particularly relevant for systems based on the ARM architecture, where the hardware varies significantly across devices.
Instead of hardcoding hardware details in the kernel, the device tree provides a flexible way to inform the kernel about the system&rsquo;s hardware layout. This simplifies kernel code and enables easier reuse across multiple hardware platforms."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://rishav-singh-0.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Device Tree (DT) in Linux Kernel","item":"https://rishav-singh-0.github.io/posts/device-tree-dt-in-linux-kernel/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Device Tree (DT) in Linux Kernel","name":"Device Tree (DT) in Linux Kernel","description":"Overview The Device Tree (DT) is a data structure used to describe the hardware components of a system in a way that is independent of the operating system and software. It is particularly relevant for systems based on the ARM architecture, where the hardware varies significantly across devices.\nInstead of hardcoding hardware details in the kernel, the device tree provides a flexible way to inform the kernel about the system\u0026rsquo;s hardware layout. This simplifies kernel code and enables easier reuse across multiple hardware platforms.\n","keywords":["Platform/DeviceTree"],"articleBody":"Overview The Device Tree (DT) is a data structure used to describe the hardware components of a system in a way that is independent of the operating system and software. It is particularly relevant for systems based on the ARM architecture, where the hardware varies significantly across devices.\nInstead of hardcoding hardware details in the kernel, the device tree provides a flexible way to inform the kernel about the system’s hardware layout. This simplifies kernel code and enables easier reuse across multiple hardware platforms.\nKey Concepts 1. Structure Device Tree Source (DTS): A human-readable text file that describes hardware. Device Tree Blob (DTB): A binary representation of the DTS, passed to the kernel at boot time. Device Tree Compiler (DTC): Used to convert DTS to DTB. 2. Syntax The syntax of a DTS file resembles a hierarchical tree structure with nodes and properties:\n/dts-v1/; / { compatible = \"rockchip,rk3399\"; memory { device_type = \"memory\"; reg = \u003c0x00000000 0x80000000\u003e; // Base address and size }; uart0: serial@ff180000 { compatible = \"rockchip,rk3399-uart\"; reg = \u003c0xff180000 0x100\u003e; interrupts = \u003c0 12 4\u003e; status = \"okay\"; }; }; Nodes: Represent physical/logical devices (e.g., CPUs, I2C buses, GPIO controllers, serial@ff180000). Properties: Key-value pairs describing device attributes (e.g., registers, interrupts, clock frequencies). 3. Key Properties compatible: Identifies the driver that should handle the device. reg: Specifies the base address and size of the device’s registers. interrupts: Describes interrupt lines and their configuration. status: Indicates if the device is active (okay) or disabled (disabled). How the Device Tree Works Bootloader Phase The bootloader (e.g., U-Boot) loads the kernel and the DTB into memory. It passes the address of the DTB to the kernel. Kernel Initialization The kernel reads the DTB to understand the hardware layout. Based on the compatible property, the kernel matches devices to their respective drivers. Driver Binding Device drivers register themselves with the kernel. The kernel matches the driver’s of_match_table with the compatible property in the DTB. If a match is found, the driver is bound to the device. Example: I2C Device on Bus 2, Slave Address 0x44 Scenario: Adding a temperature sensor (e.g., tmp102) at address 0x44 on I2C bus 2.\nStep 1: Device Tree Source (DTS) // File: myboard.dts / { compatible = \"vendor,myboard\"; model = \"My Embedded Board\"; // I2C Controller (e.g., i2c2) i2c2: i2c@40005800 { compatible = \"vendor,i2c-controller\"; reg = \u003c0x40005800 0x400\u003e; // Base address and size #address-cells = \u003c1\u003e; // Number of cells for I2C slave addresses #size-cells = \u003c0\u003e; // No size field for I2C slaves // Temperature sensor at slave address 0x44 temp_sensor: tmp102@44 { compatible = \"ti,tmp102\"; // Matches driver's `of_match_table` reg = \u003c0x44\u003e; // I2C slave address (7-bit format) interrupt-parent = \u003c\u0026gpioa\u003e; interrupts = \u003c9 IRQ_TYPE_EDGE_FALLING\u003e; // GPIO pin 9, falling edge }; }; }; Step 2: Compile the Device Tree # Compile .dts to .dtb dtc -O dtb -o myboard.dtb myboard.dts Step 3: Load the Device Tree Pass the DT blob to the kernel via the bootloader (e.g., U-Boot): load mmc 0:1 ${fdt_addr} myboard.dtb bootz ${kernel_addr} - ${fdt_addr} 4. Driver Implementation for the I2C Device Key Functions:\nProbe Function: Called when a device with a matching compatible string is found. Device Tree Parsing: Extract properties (e.g., interrupts, registers). Example Driver Code #include #include #include // Define device-specific data structure struct tmp102_data { struct i2c_client *client; int irq; }; // Platform IDs for Device Tree matching static const struct of_device_id tmp102_of_match[] = { { .compatible = \"ti,tmp102\" }, // Matches DTS `compatible` string { } }; MODULE_DEVICE_TABLE(of, tmp102_of_match); // Probe function static int tmp102_probe(struct i2c_client *client, const struct i2c_device_id *id) { struct tmp102_data *data; struct device *dev = \u0026client-\u003edev; int ret; // Allocate memory for device data data = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL); if (!data) return -ENOMEM; data-\u003eclient = client; // Get IRQ from Device Tree data-\u003eirq = irq_of_parse_and_map(dev-\u003eof_node, 0); if (data-\u003eirq \u003c= 0) { dev_err(dev, \"Failed to get IRQ\\n\"); return -EINVAL; } // Read a register from the I2C device (example) ret = i2c_smbus_read_word_swapped(client, 0x00); if (ret \u003c 0) { dev_err(dev, \"Failed to read temperature\\n\"); return ret; } dev_info(dev, \"Probed TMP102 at address 0x%02x\\n\", client-\u003eaddr); return 0; } // I2C driver structure static struct i2c_driver tmp102_driver = { .driver = { .name = \"tmp102\", .of_match_table = tmp102_of_match, }, .probe = tmp102_probe, }; module_i2c_driver(tmp102_driver); 5. Validating the Device Tree in Userspace Refer: [I2C#I2C-Tools Package in Userspace]({\u003c ref “/posts/i2c#i2c-tools-package-in-userspace/” \u003e}})\n# List I2C devices on bus 2 i2cdetect -y 2 0 1 2 ... 44 ... UU -- ... 44 ... # View DT node for the I2C device ls /proc/device-tree/i2c@40005800/tmp102@44 Writing a Kernel Driver with Device Tree Support Here is an example of a UART driver that uses the device tree.\n1. Device Tree Entry Add the following node in the DTS file for a UART device:\nuart0: serial@ff180000 { compatible = \"custom,uart\"; reg = \u003c0xff180000 0x100\u003e; interrupts = \u003c0 12 4\u003e; status = \"okay\"; }; 2. Driver Code Below is a minimal device driver that interacts with the device tree:\n#include #include #include #include #include #define DRIVER_NAME \"custom_uart\" struct uart_dev { void __iomem *base; int irq; }; static int uart_probe(struct platform_device *pdev) { struct resource *res; struct uart_dev *uart; uart = devm_kzalloc(\u0026pdev-\u003edev, sizeof(*uart), GFP_KERNEL); if (!uart) return -ENOMEM; res = platform_get_resource(pdev, IORESOURCE_MEM, 0); uart-\u003ebase = devm_ioremap_resource(\u0026pdev-\u003edev, res); if (IS_ERR(uart-\u003ebase)) return PTR_ERR(uart-\u003ebase); uart-\u003eirq = platform_get_irq(pdev, 0); if (uart-\u003eirq \u003c 0) return uart-\u003eirq; dev_info(\u0026pdev-\u003edev, \"UART probed at %p with IRQ %d\\n\", uart-\u003ebase, uart-\u003eirq); return 0; } static int uart_remove(struct platform_device *pdev) { dev_info(\u0026pdev-\u003edev, \"UART removed\\n\"); return 0; } static const struct of_device_id uart_of_match[] = { { .compatible = \"custom,uart\" }, {}, }; MODULE_DEVICE_TABLE(of, uart_of_match); static struct platform_driver uart_driver = { .driver = { .name = DRIVER_NAME, .of_match_table = uart_of_match, }, .probe = uart_probe, .remove = uart_remove, }; module_platform_driver(uart_driver); MODULE_LICENSE(\"GPL\"); MODULE_AUTHOR(\"Embedded Developer\"); MODULE_DESCRIPTION(\"Custom UART Driver\"); 3. Explanation of_match_table: Matches the compatible property in the DTB with the driver. platform_get_resource: Retrieves memory regions (registers) from the DT. platform_get_irq: Retrieves the interrupt line from the DT. devm_*: Managed functions for resource allocation, simplifying cleanup. Example Rockchip system:\nReplace \"custom,uart\" with \"rockchip,rk3399-uart\". Ensure the reg and interrupts values match your hardware’s specifications. Use this approach to add support for other peripherals (e.g., GPIO, I2C, SPI) in your system. References Linux kernel documentation: Device Tree U-Boot documentation: Device Tree Support Regmap documentation: Regmap API ","wordCount":"1050","inLanguage":"en","datePublished":"2025-01-27T17:41:00Z","dateModified":"2025-01-27T17:41:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://rishav-singh-0.github.io/posts/device-tree-dt-in-linux-kernel/"},"publisher":{"@type":"Organization","name":"Rishav's Digital Garden","logo":{"@type":"ImageObject","url":"https://rishav-singh-0.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://rishav-singh-0.github.io/ accesskey=h title="Rishav's Digital Garden (Alt + H)">Rishav's Digital Garden</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://rishav-singh-0.github.io/archives title=Archive><span>Archive</span></a></li><li><a href=https://rishav-singh-0.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://rishav-singh-0.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Device Tree (DT) in Linux Kernel</h1><div class=post-meta><span title='2025-01-27 17:41:00 +0000 UTC'>January 27, 2025</span>&nbsp;·&nbsp;5 min</div></header><div class=post-content><h2 id=overview>Overview<a hidden class=anchor aria-hidden=true href=#overview>#</a></h2><p>The Device Tree (DT) is a data structure used to describe the hardware components of a system in a way that is independent of the operating system and software. It is particularly relevant for systems based on the ARM architecture, where the hardware varies significantly across devices.</p><p>Instead of hardcoding hardware details in the kernel, the device tree provides a flexible way to inform the kernel about the system&rsquo;s hardware layout. This simplifies kernel code and enables easier reuse across multiple hardware platforms.</p><hr><h2 id=key-concepts>Key Concepts<a hidden class=anchor aria-hidden=true href=#key-concepts>#</a></h2><h3 id=1-structure>1. Structure<a hidden class=anchor aria-hidden=true href=#1-structure>#</a></h3><ul><li><strong>Device Tree Source (DTS):</strong> A human-readable text file that describes hardware.</li><li><strong>Device Tree Blob (DTB):</strong> A binary representation of the DTS, passed to the kernel at boot time.</li><li><strong>Device Tree Compiler (DTC):</strong> Used to convert DTS to DTB.</li></ul><h3 id=2-syntax>2. Syntax<a hidden class=anchor aria-hidden=true href=#2-syntax>#</a></h3><p>The syntax of a DTS file resembles a hierarchical tree structure with nodes and properties:</p><pre tabindex=0><code class=language-dts data-lang=dts>/dts-v1/;

/ {
    compatible = &#34;rockchip,rk3399&#34;;

    memory {
        device_type = &#34;memory&#34;;
        reg = &lt;0x00000000 0x80000000&gt;; // Base address and size
    };

    uart0: serial@ff180000 {
        compatible = &#34;rockchip,rk3399-uart&#34;;
        reg = &lt;0xff180000 0x100&gt;;
        interrupts = &lt;0 12 4&gt;;
        status = &#34;okay&#34;;
    };
};
</code></pre><ul><li><strong>Nodes:</strong> Represent physical/logical devices (e.g., CPUs, I2C buses, GPIO controllers, <code>serial@ff180000</code>).</li><li><strong>Properties:</strong> Key-value pairs describing device attributes (e.g., registers, interrupts, clock frequencies).</li></ul><h3 id=3-key-properties>3. Key Properties<a hidden class=anchor aria-hidden=true href=#3-key-properties>#</a></h3><ul><li><strong><code>compatible</code>:</strong> Identifies the driver that should handle the device.</li><li><strong><code>reg</code>:</strong> Specifies the base address and size of the device&rsquo;s registers.</li><li><strong><code>interrupts</code>:</strong> Describes interrupt lines and their configuration.</li><li><strong><code>status</code>:</strong> Indicates if the device is active (<code>okay</code>) or disabled (<code>disabled</code>).</li></ul><hr><h2 id=how-the-device-tree-works>How the Device Tree Works<a hidden class=anchor aria-hidden=true href=#how-the-device-tree-works>#</a></h2><ol><li><strong>Bootloader Phase</strong><ul><li>The bootloader (e.g., U-Boot) loads the kernel and the DTB into memory.</li><li>It passes the address of the DTB to the kernel.</li></ul></li><li><strong>Kernel Initialization</strong><ul><li>The kernel reads the DTB to understand the hardware layout.</li><li>Based on the <code>compatible</code> property, the kernel matches devices to their respective drivers.</li></ul></li><li><strong>Driver Binding</strong><ul><li>Device drivers register themselves with the kernel.</li><li>The kernel matches the driver’s <code>of_match_table</code> with the <code>compatible</code> property in the DTB.</li><li>If a match is found, the driver is bound to the device.</li></ul></li></ol><hr><p><strong>Example:</strong> I2C Device on Bus 2, Slave Address 0x44
Scenario: Adding a temperature sensor (e.g., tmp102) at address 0x44 on I2C bus 2.</p><h5 id=step-1-device-tree-source-dts>Step 1: Device Tree Source (DTS)<a hidden class=anchor aria-hidden=true href=#step-1-device-tree-source-dts>#</a></h5><pre tabindex=0><code class=language-dts data-lang=dts>// File: myboard.dts  

/ {  
    compatible = &#34;vendor,myboard&#34;;  
    model = &#34;My Embedded Board&#34;;  

    // I2C Controller (e.g., i2c2)  
    i2c2: i2c@40005800 {  
        compatible = &#34;vendor,i2c-controller&#34;;  
        reg = &lt;0x40005800 0x400&gt;;     // Base address and size  
        #address-cells = &lt;1&gt;;         // Number of cells for I2C slave addresses  
        #size-cells = &lt;0&gt;;            // No size field for I2C slaves  

        // Temperature sensor at slave address 0x44  
        temp_sensor: tmp102@44 {  
            compatible = &#34;ti,tmp102&#34;; // Matches driver&#39;s `of_match_table`  
            reg = &lt;0x44&gt;;             // I2C slave address (7-bit format)  
            interrupt-parent = &lt;&amp;gpioa&gt;;  
            interrupts = &lt;9 IRQ_TYPE_EDGE_FALLING&gt;; // GPIO pin 9, falling edge  
        };  
    };  
};  
</code></pre><h5 id=step-2-compile-the-device-tree>Step 2: Compile the Device Tree<a hidden class=anchor aria-hidden=true href=#step-2-compile-the-device-tree>#</a></h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># Compile .dts to .dtb  </span>
</span></span><span style=display:flex><span>dtc -O dtb -o myboard.dtb myboard.dts  
</span></span></code></pre></div><h5 id=step-3-load-the-device-tree>Step 3: Load the Device Tree<a hidden class=anchor aria-hidden=true href=#step-3-load-the-device-tree>#</a></h5><ul><li>Pass the DT blob to the kernel via the bootloader (e.g., U-Boot):</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>load mmc 0:1 <span style=color:#e6db74>${</span>fdt_addr<span style=color:#e6db74>}</span> myboard.dtb  
</span></span><span style=display:flex><span>bootz <span style=color:#e6db74>${</span>kernel_addr<span style=color:#e6db74>}</span> - <span style=color:#e6db74>${</span>fdt_addr<span style=color:#e6db74>}</span>
</span></span></code></pre></div><h5 id=4-driver-implementation-for-the-i2c-device>4. Driver Implementation for the I2C Device<a hidden class=anchor aria-hidden=true href=#4-driver-implementation-for-the-i2c-device>#</a></h5><p><strong>Key Functions</strong>:</p><ul><li><strong>Probe Function</strong>: Called when a device with a matching <code>compatible</code> string is found.</li><li><strong>Device Tree Parsing</strong>: Extract properties (e.g., interrupts, registers).</li></ul><h5 id=example-driver-code>Example Driver Code<a hidden class=anchor aria-hidden=true href=#example-driver-code>#</a></h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;linux/module.h&gt;  </span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;linux/i2c.h&gt;  </span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;linux/of.h&gt;  </span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Define device-specific data structure  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> tmp102_data {  
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> i2c_client <span style=color:#f92672>*</span>client;  
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> irq;  
</span></span><span style=display:flex><span>};  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Platform IDs for Device Tree matching  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>struct</span> of_device_id tmp102_of_match[] <span style=color:#f92672>=</span> {  
</span></span><span style=display:flex><span>    { .compatible <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;ti,tmp102&#34;</span> }, <span style=color:#75715e>// Matches DTS `compatible` string  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    { }  
</span></span><span style=display:flex><span>};  
</span></span><span style=display:flex><span><span style=color:#a6e22e>MODULE_DEVICE_TABLE</span>(of, tmp102_of_match);  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Probe function  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>tmp102_probe</span>(<span style=color:#66d9ef>struct</span> i2c_client <span style=color:#f92672>*</span>client,  
</span></span><span style=display:flex><span>                       <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>struct</span> i2c_device_id <span style=color:#f92672>*</span>id)  
</span></span><span style=display:flex><span>{  
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> tmp102_data <span style=color:#f92672>*</span>data;  
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> device <span style=color:#f92672>*</span>dev <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>client<span style=color:#f92672>-&gt;</span>dev;  
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> ret;  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Allocate memory for device data  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    data <span style=color:#f92672>=</span> <span style=color:#a6e22e>devm_kzalloc</span>(dev, <span style=color:#66d9ef>sizeof</span>(<span style=color:#f92672>*</span>data), GFP_KERNEL);  
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>data)  
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span>ENOMEM;  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    data<span style=color:#f92672>-&gt;</span>client <span style=color:#f92672>=</span> client;  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Get IRQ from Device Tree  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    data<span style=color:#f92672>-&gt;</span>irq <span style=color:#f92672>=</span> <span style=color:#a6e22e>irq_of_parse_and_map</span>(dev<span style=color:#f92672>-&gt;</span>of_node, <span style=color:#ae81ff>0</span>);  
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (data<span style=color:#f92672>-&gt;</span>irq <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span>) {  
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>dev_err</span>(dev, <span style=color:#e6db74>&#34;Failed to get IRQ</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);  
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span>EINVAL;  
</span></span><span style=display:flex><span>    }  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Read a register from the I2C device (example)  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    ret <span style=color:#f92672>=</span> <span style=color:#a6e22e>i2c_smbus_read_word_swapped</span>(client, <span style=color:#ae81ff>0x00</span>);  
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (ret <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>) {  
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>dev_err</span>(dev, <span style=color:#e6db74>&#34;Failed to read temperature</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);  
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> ret;  
</span></span><span style=display:flex><span>    }  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>dev_info</span>(dev, <span style=color:#e6db74>&#34;Probed TMP102 at address 0x%02x</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, client<span style=color:#f92672>-&gt;</span>addr);  
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;  
</span></span><span style=display:flex><span>}  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// I2C driver structure  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>struct</span> i2c_driver tmp102_driver <span style=color:#f92672>=</span> {  
</span></span><span style=display:flex><span>    .driver <span style=color:#f92672>=</span> {  
</span></span><span style=display:flex><span>        .name <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;tmp102&#34;</span>,  
</span></span><span style=display:flex><span>        .of_match_table <span style=color:#f92672>=</span> tmp102_of_match,  
</span></span><span style=display:flex><span>    },  
</span></span><span style=display:flex><span>    .probe <span style=color:#f92672>=</span> tmp102_probe,  
</span></span><span style=display:flex><span>};  
</span></span><span style=display:flex><span><span style=color:#a6e22e>module_i2c_driver</span>(tmp102_driver);
</span></span></code></pre></div><h5 id=5-validating-the-device-tree-in-userspace>5. Validating the Device Tree in Userspace<a hidden class=anchor aria-hidden=true href=#5-validating-the-device-tree-in-userspace>#</a></h5><p>Refer: [I2C#I2C-Tools Package in Userspace]({&lt; ref &ldquo;/posts/i2c#i2c-tools-package-in-userspace/&rdquo; >}})</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># List I2C devices on bus 2  </span>
</span></span><span style=display:flex><span>i2cdetect -y <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0</span>  <span style=color:#ae81ff>1</span>  <span style=color:#ae81ff>2</span> ... <span style=color:#ae81ff>44</span> ...  
</span></span><span style=display:flex><span>    UU -- ... <span style=color:#ae81ff>44</span> ...  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># View DT node for the I2C device  </span>
</span></span><span style=display:flex><span>ls /proc/device-tree/i2c@40005800/tmp102@44
</span></span></code></pre></div><hr><h2 id=writing-a-kernel-driver-with-device-tree-support>Writing a Kernel Driver with Device Tree Support<a hidden class=anchor aria-hidden=true href=#writing-a-kernel-driver-with-device-tree-support>#</a></h2><p>Here is an example of a UART driver that uses the device tree.</p><h3 id=1-device-tree-entry>1. Device Tree Entry<a hidden class=anchor aria-hidden=true href=#1-device-tree-entry>#</a></h3><p>Add the following node in the DTS file for a UART device:</p><pre tabindex=0><code class=language-dts data-lang=dts>uart0: serial@ff180000 {
    compatible = &#34;custom,uart&#34;;
    reg = &lt;0xff180000 0x100&gt;;
    interrupts = &lt;0 12 4&gt;;
    status = &#34;okay&#34;;
};
</code></pre><h3 id=2-driver-code>2. Driver Code<a hidden class=anchor aria-hidden=true href=#2-driver-code>#</a></h3><p>Below is a minimal device driver that interacts with the device tree:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;linux/module.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;linux/platform_device.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;linux/of.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;linux/io.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;linux/interrupt.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define DRIVER_NAME &#34;custom_uart&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> uart_dev {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> __iomem <span style=color:#f92672>*</span>base;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> irq;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>uart_probe</span>(<span style=color:#66d9ef>struct</span> platform_device <span style=color:#f92672>*</span>pdev) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> resource <span style=color:#f92672>*</span>res;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> uart_dev <span style=color:#f92672>*</span>uart;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    uart <span style=color:#f92672>=</span> <span style=color:#a6e22e>devm_kzalloc</span>(<span style=color:#f92672>&amp;</span>pdev<span style=color:#f92672>-&gt;</span>dev, <span style=color:#66d9ef>sizeof</span>(<span style=color:#f92672>*</span>uart), GFP_KERNEL);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>uart)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span>ENOMEM;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    res <span style=color:#f92672>=</span> <span style=color:#a6e22e>platform_get_resource</span>(pdev, IORESOURCE_MEM, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    uart<span style=color:#f92672>-&gt;</span>base <span style=color:#f92672>=</span> <span style=color:#a6e22e>devm_ioremap_resource</span>(<span style=color:#f92672>&amp;</span>pdev<span style=color:#f92672>-&gt;</span>dev, res);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>IS_ERR</span>(uart<span style=color:#f92672>-&gt;</span>base))
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>PTR_ERR</span>(uart<span style=color:#f92672>-&gt;</span>base);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    uart<span style=color:#f92672>-&gt;</span>irq <span style=color:#f92672>=</span> <span style=color:#a6e22e>platform_get_irq</span>(pdev, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (uart<span style=color:#f92672>-&gt;</span>irq <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> uart<span style=color:#f92672>-&gt;</span>irq;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>dev_info</span>(<span style=color:#f92672>&amp;</span>pdev<span style=color:#f92672>-&gt;</span>dev, <span style=color:#e6db74>&#34;UART probed at %p with IRQ %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, uart<span style=color:#f92672>-&gt;</span>base, uart<span style=color:#f92672>-&gt;</span>irq);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>uart_remove</span>(<span style=color:#66d9ef>struct</span> platform_device <span style=color:#f92672>*</span>pdev) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>dev_info</span>(<span style=color:#f92672>&amp;</span>pdev<span style=color:#f92672>-&gt;</span>dev, <span style=color:#e6db74>&#34;UART removed</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>struct</span> of_device_id uart_of_match[] <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>    { .compatible <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;custom,uart&#34;</span> },
</span></span><span style=display:flex><span>    {},
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#a6e22e>MODULE_DEVICE_TABLE</span>(of, uart_of_match);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>struct</span> platform_driver uart_driver <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>    .driver <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>        .name <span style=color:#f92672>=</span> DRIVER_NAME,
</span></span><span style=display:flex><span>        .of_match_table <span style=color:#f92672>=</span> uart_of_match,
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    .probe <span style=color:#f92672>=</span> uart_probe,
</span></span><span style=display:flex><span>    .remove <span style=color:#f92672>=</span> uart_remove,
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#a6e22e>module_platform_driver</span>(uart_driver);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>MODULE_LICENSE</span>(<span style=color:#e6db74>&#34;GPL&#34;</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>MODULE_AUTHOR</span>(<span style=color:#e6db74>&#34;Embedded Developer&#34;</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>MODULE_DESCRIPTION</span>(<span style=color:#e6db74>&#34;Custom UART Driver&#34;</span>);
</span></span></code></pre></div><h3 id=3-explanation>3. Explanation<a hidden class=anchor aria-hidden=true href=#3-explanation>#</a></h3><ul><li><strong><code>of_match_table</code>:</strong> Matches the <code>compatible</code> property in the DTB with the driver.</li><li><strong><code>platform_get_resource</code>:</strong> Retrieves memory regions (registers) from the DT.</li><li><strong><code>platform_get_irq</code>:</strong> Retrieves the interrupt line from the DT.</li><li><strong><code>devm_*</code>:</strong> Managed functions for resource allocation, simplifying cleanup.</li></ul><hr><h2 id=example>Example<a hidden class=anchor aria-hidden=true href=#example>#</a></h2><p>Rockchip system:</p><ul><li>Replace <code>"custom,uart"</code> with <code>"rockchip,rk3399-uart"</code>.</li><li>Ensure the <code>reg</code> and <code>interrupts</code> values match your hardware&rsquo;s specifications.</li><li>Use this approach to add support for other peripherals (e.g., GPIO, I2C, SPI) in your system.</li></ul><hr><h2 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h2><ul><li>Linux kernel documentation: <a href=https://www.kernel.org/doc/html/latest/devicetree/index.html>Device Tree</a></li><li>U-Boot documentation: <a href=https://u-boot.readthedocs.io/en/latest/>Device Tree Support</a></li><li>Regmap documentation: Regmap API</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://rishav-singh-0.github.io/tags/platform/devicetree/>Platform/DeviceTree</a></li></ul><nav class=paginav><a class=prev href=https://rishav-singh-0.github.io/posts/crc-cyclic-redundancy-check/><span class=title>« Prev</span><br><span>CRC (Cyclic Redundancy Check)</span>
</a><a class=next href=https://rishav-singh-0.github.io/posts/character-device-management-in-kernel-drivers/><span class=title>Next »</span><br><span>Character Device Management in Kernel Drivers</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://rishav-singh-0.github.io/>Rishav's Digital Garden</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>