<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Character Device Management in Kernel Drivers | Rishav's Digital Garden</title>
<meta name=keywords content="Platform/Drivers"><meta name=description content='Overview
Character devices allow byte-by-byte communication between user-space applications and kernel drivers. They are commonly used for devices like serial ports, sensors, and custom hardware interfaces. The Linux kernel provides mechanisms for registering, managing, and interacting with character devices via a device file in /dev.

Registering a Character Device
To register a character device, the driver needs to:
1. Allocate a Major and Minor Number:

Each character device is identified by a major number (device type) and a minor number (specific device). The major number indicates the driver associated with the device, while the minor number is used to differentiate between multiple devices handled by the same driver. If major and minor numbers are repeated, it can cause conflicts and lead to incorrect device identification. To avoid this, the kernel provides alloc_chrdev_region, a function to dynamically allocate major and minor numbers, ensuring uniqueness. These numbers are used in the /dev directory to associate device files with their corresponding drivers.
Use alloc_chrdev_region to dynamically allocate a major number.

dev_t dev;
int result;

// kernel/fs/char_dev.c
// int alloc_chrdev_region(dev_t *dev, unsigned baseminor, unsigned count, const char *name)

result = alloc_chrdev_region(&amp;dev, 0, 1, "my_char_device");
if (result < 0) {
	pr_err("Failed to allocate major number\n");
	return result;
}

pr_info("Device registered with major %d, minor %d\n", MAJOR(dev), MINOR(dev));
2. Initialize and Register the Device:

Define a cdev structure and initialize it with file operations.
Use cdev_add to register the device with the kernel.

struct cdev my_cdev;

cdev_init(&amp;my_cdev, &amp;my_fops);
my_cdev.owner = THIS_MODULE;

result = cdev_add(&amp;my_cdev, dev, 1);
if (result < 0) {
	pr_err("Failed to add cdev\n");
	unregister_chrdev_region(dev, 1);
	return result;
}
3. Create a Device File (Optional):

Creating a device file in /dev is optional because character devices can be accessed directly using their major and minor numbers through system calls or user-space libraries, bypassing the need for a device file. However, creating a file in /dev makes interaction more user-friendly by providing a standard interface.
To interact with a character device without creating a device file, you can use system calls like mknod to create a temporary device node or interact with the device directly using its major and minor numbers programmatically.
Use class_create and device_create to automatically create a device file in /dev.

struct class *my_class;

my_class = class_create(THIS_MODULE, "my_device_class");
if (IS_ERR(my_class)) {
	pr_err("Failed to create class\n");
	cdev_del(&amp;my_cdev);
	unregister_chrdev_region(dev, 1);
	return PTR_ERR(my_class);
}

device_create(my_class, NULL, dev, NULL, "my_char_device");

File Operations
Character devices are controlled through a set of file operations defined in a struct file_operations. These operations determine how the device responds to system calls like open, read, write, and ioctl.'><meta name=author content><link rel=canonical href=https://rishav-singh-0.github.io/posts/character-device-management-in-kernel-drivers/><link crossorigin=anonymous href=/assets/css/stylesheet.2211ca3164be7830024f6aad2b3a2e520843a64f8f048445c3401c1249aa051d.css integrity="sha256-IhHKMWS+eDACT2qtKzouUghDpk+PBIRFw0AcEkmqBR0=" rel="preload stylesheet" as=style><link rel=icon href=https://rishav-singh-0.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://rishav-singh-0.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://rishav-singh-0.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://rishav-singh-0.github.io/apple-touch-icon.png><link rel=mask-icon href=https://rishav-singh-0.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://rishav-singh-0.github.io/posts/character-device-management-in-kernel-drivers/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://rishav-singh-0.github.io/posts/character-device-management-in-kernel-drivers/"><meta property="og:site_name" content="Rishav's Digital Garden"><meta property="og:title" content="Character Device Management in Kernel Drivers"><meta property="og:description" content='Overview Character devices allow byte-by-byte communication between user-space applications and kernel drivers. They are commonly used for devices like serial ports, sensors, and custom hardware interfaces. The Linux kernel provides mechanisms for registering, managing, and interacting with character devices via a device file in /dev.
Registering a Character Device To register a character device, the driver needs to:
1. Allocate a Major and Minor Number: Each character device is identified by a major number (device type) and a minor number (specific device). The major number indicates the driver associated with the device, while the minor number is used to differentiate between multiple devices handled by the same driver. If major and minor numbers are repeated, it can cause conflicts and lead to incorrect device identification. To avoid this, the kernel provides alloc_chrdev_region, a function to dynamically allocate major and minor numbers, ensuring uniqueness. These numbers are used in the /dev directory to associate device files with their corresponding drivers. Use alloc_chrdev_region to dynamically allocate a major number. dev_t dev; int result; // kernel/fs/char_dev.c // int alloc_chrdev_region(dev_t *dev, unsigned baseminor, unsigned count, const char *name) result = alloc_chrdev_region(&amp;dev, 0, 1, "my_char_device"); if (result < 0) { pr_err("Failed to allocate major number\n"); return result; } pr_info("Device registered with major %d, minor %d\n", MAJOR(dev), MINOR(dev)); 2. Initialize and Register the Device: Define a cdev structure and initialize it with file operations. Use cdev_add to register the device with the kernel. struct cdev my_cdev; cdev_init(&amp;my_cdev, &amp;my_fops); my_cdev.owner = THIS_MODULE; result = cdev_add(&amp;my_cdev, dev, 1); if (result < 0) { pr_err("Failed to add cdev\n"); unregister_chrdev_region(dev, 1); return result; } 3. Create a Device File (Optional): Creating a device file in /dev is optional because character devices can be accessed directly using their major and minor numbers through system calls or user-space libraries, bypassing the need for a device file. However, creating a file in /dev makes interaction more user-friendly by providing a standard interface. To interact with a character device without creating a device file, you can use system calls like mknod to create a temporary device node or interact with the device directly using its major and minor numbers programmatically. Use class_create and device_create to automatically create a device file in /dev. struct class *my_class; my_class = class_create(THIS_MODULE, "my_device_class"); if (IS_ERR(my_class)) { pr_err("Failed to create class\n"); cdev_del(&amp;my_cdev); unregister_chrdev_region(dev, 1); return PTR_ERR(my_class); } device_create(my_class, NULL, dev, NULL, "my_char_device"); File Operations Character devices are controlled through a set of file operations defined in a struct file_operations. These operations determine how the device responds to system calls like open, read, write, and ioctl.'><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-01-24T17:54:00+00:00"><meta property="article:modified_time" content="2025-01-24T17:54:00+00:00"><meta property="article:tag" content="Platform/Drivers"><meta name=twitter:card content="summary"><meta name=twitter:title content="Character Device Management in Kernel Drivers"><meta name=twitter:description content='Overview
Character devices allow byte-by-byte communication between user-space applications and kernel drivers. They are commonly used for devices like serial ports, sensors, and custom hardware interfaces. The Linux kernel provides mechanisms for registering, managing, and interacting with character devices via a device file in /dev.

Registering a Character Device
To register a character device, the driver needs to:
1. Allocate a Major and Minor Number:

Each character device is identified by a major number (device type) and a minor number (specific device). The major number indicates the driver associated with the device, while the minor number is used to differentiate between multiple devices handled by the same driver. If major and minor numbers are repeated, it can cause conflicts and lead to incorrect device identification. To avoid this, the kernel provides alloc_chrdev_region, a function to dynamically allocate major and minor numbers, ensuring uniqueness. These numbers are used in the /dev directory to associate device files with their corresponding drivers.
Use alloc_chrdev_region to dynamically allocate a major number.

dev_t dev;
int result;

// kernel/fs/char_dev.c
// int alloc_chrdev_region(dev_t *dev, unsigned baseminor, unsigned count, const char *name)

result = alloc_chrdev_region(&amp;dev, 0, 1, "my_char_device");
if (result < 0) {
	pr_err("Failed to allocate major number\n");
	return result;
}

pr_info("Device registered with major %d, minor %d\n", MAJOR(dev), MINOR(dev));
2. Initialize and Register the Device:

Define a cdev structure and initialize it with file operations.
Use cdev_add to register the device with the kernel.

struct cdev my_cdev;

cdev_init(&amp;my_cdev, &amp;my_fops);
my_cdev.owner = THIS_MODULE;

result = cdev_add(&amp;my_cdev, dev, 1);
if (result < 0) {
	pr_err("Failed to add cdev\n");
	unregister_chrdev_region(dev, 1);
	return result;
}
3. Create a Device File (Optional):

Creating a device file in /dev is optional because character devices can be accessed directly using their major and minor numbers through system calls or user-space libraries, bypassing the need for a device file. However, creating a file in /dev makes interaction more user-friendly by providing a standard interface.
To interact with a character device without creating a device file, you can use system calls like mknod to create a temporary device node or interact with the device directly using its major and minor numbers programmatically.
Use class_create and device_create to automatically create a device file in /dev.

struct class *my_class;

my_class = class_create(THIS_MODULE, "my_device_class");
if (IS_ERR(my_class)) {
	pr_err("Failed to create class\n");
	cdev_del(&amp;my_cdev);
	unregister_chrdev_region(dev, 1);
	return PTR_ERR(my_class);
}

device_create(my_class, NULL, dev, NULL, "my_char_device");

File Operations
Character devices are controlled through a set of file operations defined in a struct file_operations. These operations determine how the device responds to system calls like open, read, write, and ioctl.'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://rishav-singh-0.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Character Device Management in Kernel Drivers","item":"https://rishav-singh-0.github.io/posts/character-device-management-in-kernel-drivers/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Character Device Management in Kernel Drivers","name":"Character Device Management in Kernel Drivers","description":"Overview Character devices allow byte-by-byte communication between user-space applications and kernel drivers. They are commonly used for devices like serial ports, sensors, and custom hardware interfaces. The Linux kernel provides mechanisms for registering, managing, and interacting with character devices via a device file in /dev.\nRegistering a Character Device To register a character device, the driver needs to:\n1. Allocate a Major and Minor Number: Each character device is identified by a major number (device type) and a minor number (specific device). The major number indicates the driver associated with the device, while the minor number is used to differentiate between multiple devices handled by the same driver. If major and minor numbers are repeated, it can cause conflicts and lead to incorrect device identification. To avoid this, the kernel provides alloc_chrdev_region, a function to dynamically allocate major and minor numbers, ensuring uniqueness. These numbers are used in the /dev directory to associate device files with their corresponding drivers. Use alloc_chrdev_region to dynamically allocate a major number. dev_t dev; int result; // kernel/fs/char_dev.c // int alloc_chrdev_region(dev_t *dev, unsigned baseminor, unsigned count, const char *name) result = alloc_chrdev_region(\u0026amp;dev, 0, 1, \u0026#34;my_char_device\u0026#34;); if (result \u0026lt; 0) { pr_err(\u0026#34;Failed to allocate major number\\n\u0026#34;); return result; } pr_info(\u0026#34;Device registered with major %d, minor %d\\n\u0026#34;, MAJOR(dev), MINOR(dev)); 2. Initialize and Register the Device: Define a cdev structure and initialize it with file operations. Use cdev_add to register the device with the kernel. struct cdev my_cdev; cdev_init(\u0026amp;my_cdev, \u0026amp;my_fops); my_cdev.owner = THIS_MODULE; result = cdev_add(\u0026amp;my_cdev, dev, 1); if (result \u0026lt; 0) { pr_err(\u0026#34;Failed to add cdev\\n\u0026#34;); unregister_chrdev_region(dev, 1); return result; } 3. Create a Device File (Optional): Creating a device file in /dev is optional because character devices can be accessed directly using their major and minor numbers through system calls or user-space libraries, bypassing the need for a device file. However, creating a file in /dev makes interaction more user-friendly by providing a standard interface. To interact with a character device without creating a device file, you can use system calls like mknod to create a temporary device node or interact with the device directly using its major and minor numbers programmatically. Use class_create and device_create to automatically create a device file in /dev. struct class *my_class; my_class = class_create(THIS_MODULE, \u0026#34;my_device_class\u0026#34;); if (IS_ERR(my_class)) { pr_err(\u0026#34;Failed to create class\\n\u0026#34;); cdev_del(\u0026amp;my_cdev); unregister_chrdev_region(dev, 1); return PTR_ERR(my_class); } device_create(my_class, NULL, dev, NULL, \u0026#34;my_char_device\u0026#34;); File Operations Character devices are controlled through a set of file operations defined in a struct file_operations. These operations determine how the device responds to system calls like open, read, write, and ioctl.\n","keywords":["Platform/Drivers"],"articleBody":"Overview Character devices allow byte-by-byte communication between user-space applications and kernel drivers. They are commonly used for devices like serial ports, sensors, and custom hardware interfaces. The Linux kernel provides mechanisms for registering, managing, and interacting with character devices via a device file in /dev.\nRegistering a Character Device To register a character device, the driver needs to:\n1. Allocate a Major and Minor Number: Each character device is identified by a major number (device type) and a minor number (specific device). The major number indicates the driver associated with the device, while the minor number is used to differentiate between multiple devices handled by the same driver. If major and minor numbers are repeated, it can cause conflicts and lead to incorrect device identification. To avoid this, the kernel provides alloc_chrdev_region, a function to dynamically allocate major and minor numbers, ensuring uniqueness. These numbers are used in the /dev directory to associate device files with their corresponding drivers. Use alloc_chrdev_region to dynamically allocate a major number. dev_t dev; int result; // kernel/fs/char_dev.c // int alloc_chrdev_region(dev_t *dev, unsigned baseminor, unsigned count, const char *name) result = alloc_chrdev_region(\u0026dev, 0, 1, \"my_char_device\"); if (result \u003c 0) { pr_err(\"Failed to allocate major number\\n\"); return result; } pr_info(\"Device registered with major %d, minor %d\\n\", MAJOR(dev), MINOR(dev)); 2. Initialize and Register the Device: Define a cdev structure and initialize it with file operations. Use cdev_add to register the device with the kernel. struct cdev my_cdev; cdev_init(\u0026my_cdev, \u0026my_fops); my_cdev.owner = THIS_MODULE; result = cdev_add(\u0026my_cdev, dev, 1); if (result \u003c 0) { pr_err(\"Failed to add cdev\\n\"); unregister_chrdev_region(dev, 1); return result; } 3. Create a Device File (Optional): Creating a device file in /dev is optional because character devices can be accessed directly using their major and minor numbers through system calls or user-space libraries, bypassing the need for a device file. However, creating a file in /dev makes interaction more user-friendly by providing a standard interface. To interact with a character device without creating a device file, you can use system calls like mknod to create a temporary device node or interact with the device directly using its major and minor numbers programmatically. Use class_create and device_create to automatically create a device file in /dev. struct class *my_class; my_class = class_create(THIS_MODULE, \"my_device_class\"); if (IS_ERR(my_class)) { pr_err(\"Failed to create class\\n\"); cdev_del(\u0026my_cdev); unregister_chrdev_region(dev, 1); return PTR_ERR(my_class); } device_create(my_class, NULL, dev, NULL, \"my_char_device\"); File Operations Character devices are controlled through a set of file operations defined in a struct file_operations. These operations determine how the device responds to system calls like open, read, write, and ioctl.\n1. Define File Operations: static ssize_t my_read(struct file *file, char __user *buf, size_t len, loff_t *offset) { char data[] = \"Hello from kernel!\\n\"; size_t datalen = strlen(data); if (*offset \u003e= datalen) return 0; if (len \u003e datalen - *offset) len = datalen - *offset; if (copy_to_user(buf, data + *offset, len)) return -EFAULT; *offset += len; return len; } static ssize_t my_write(struct file *file, const char __user *buf, size_t len, loff_t *offset) { char kbuf[128]; if (len \u003e sizeof(kbuf) - 1) len = sizeof(kbuf) - 1; if (copy_from_user(kbuf, buf, len)) return -EFAULT; kbuf[len] = '\\0'; pr_info(\"Data from user: %s\\n\", kbuf); return len; } static int my_open(struct inode *inode, struct file *file) { pr_info(\"Device opened\\n\"); return 0; } static int my_release(struct inode *inode, struct file *file) { pr_info(\"Device closed\\n\"); return 0; } static struct file_operations my_fops = { .owner = THIS_MODULE, .read = my_read, .write = my_write, .open = my_open, .release = my_release, }; 2. Explanation of Generic Operations: open: Called when the device is accessed using open(). Used for initialization. release: Called when the device is closed. read: Transfers data from the kernel to user-space. write: Transfers data from user-space to the kernel. Cleaning Up When unloading the driver, release allocated resources:\nstatic void __exit my_exit(void) { device_destroy(my_class, dev); class_destroy(my_class); cdev_del(\u0026my_cdev); unregister_chrdev_region(dev, 1); pr_info(\"Character device unregistered\\n\"); } module_exit(my_exit); Example User-Space Interaction Write a user-space program to interact with the character device:\n#include #include #include int main() { int fd; char buffer[128]; fd = open(\"/dev/my_char_device\", O_RDWR); if (fd \u003c 0) { perror(\"Failed to open device\"); return -1; } // Write to device write(fd, \"Hello, kernel!\", 14); // Read from device read(fd, buffer, sizeof(buffer)); printf(\"Data from device: %s\\n\", buffer); close(fd); return 0; } Best Practices Error Handling: Validate user input and handle edge cases. Ensure proper cleanup in case of initialization failures. Use Helper Functions: Use alloc_chrdev_region instead of hardcoding major numbers. copy_to_user and copy_from_user are essential for secure data exchange between kernel space and user space. These functions ensure that the kernel does not directly access user-space memory, which could lead to security risks and undefined behavior due to memory access violations. Instead, they provide controlled, validated mechanisms for copying data. Alternatively, functions like memdup_user can be used when copying large blocks of data into kernel space. These methods ensure safe interaction between different memory domains, protecting system stability. Device Permissions: Set appropriate file permissions on the device file to avoid unauthorized access. Documentation: Provide clear documentation for user-space developers on how to interact with the device. ","wordCount":"844","inLanguage":"en","datePublished":"2025-01-24T17:54:00Z","dateModified":"2025-01-24T17:54:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://rishav-singh-0.github.io/posts/character-device-management-in-kernel-drivers/"},"publisher":{"@type":"Organization","name":"Rishav's Digital Garden","logo":{"@type":"ImageObject","url":"https://rishav-singh-0.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://rishav-singh-0.github.io/ accesskey=h title="Rishav's Digital Garden (Alt + H)">Rishav's Digital Garden</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://rishav-singh-0.github.io/archives title=Archive><span>Archive</span></a></li><li><a href=https://rishav-singh-0.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://rishav-singh-0.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Character Device Management in Kernel Drivers</h1><div class=post-meta><span title='2025-01-24 17:54:00 +0000 UTC'>January 24, 2025</span>&nbsp;·&nbsp;4 min</div></header><div class=post-content><h2 id=overview>Overview<a hidden class=anchor aria-hidden=true href=#overview>#</a></h2><p>Character devices allow byte-by-byte communication between user-space applications and kernel drivers. They are commonly used for devices like serial ports, sensors, and custom hardware interfaces. The Linux kernel provides mechanisms for registering, managing, and interacting with character devices via a device file in <code>/dev</code>.</p><hr><h2 id=registering-a-character-device>Registering a Character Device<a hidden class=anchor aria-hidden=true href=#registering-a-character-device>#</a></h2><p>To register a character device, the driver needs to:</p><h4 id=1-allocate-a-major-and-minor-number>1. Allocate a Major and Minor Number:<a hidden class=anchor aria-hidden=true href=#1-allocate-a-major-and-minor-number>#</a></h4><ul><li>Each character device is identified by a major number (device type) and a minor number (specific device). The major number indicates the driver associated with the device, while the minor number is used to differentiate between multiple devices handled by the same driver. If major and minor numbers are repeated, it can cause conflicts and lead to incorrect device identification. To avoid this, the kernel provides <code>alloc_chrdev_region</code>, a function to dynamically allocate major and minor numbers, ensuring uniqueness. These numbers are used in the <code>/dev</code> directory to associate device files with their corresponding drivers.</li><li>Use <code>alloc_chrdev_region</code> to dynamically allocate a major number.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>dev_t</span> dev;
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> result;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// kernel/fs/char_dev.c
</span></span></span><span style=display:flex><span><span style=color:#75715e>// int alloc_chrdev_region(dev_t *dev, unsigned baseminor, unsigned count, const char *name)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>result <span style=color:#f92672>=</span> <span style=color:#a6e22e>alloc_chrdev_region</span>(<span style=color:#f92672>&amp;</span>dev, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, <span style=color:#e6db74>&#34;my_char_device&#34;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (result <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>pr_err</span>(<span style=color:#e6db74>&#34;Failed to allocate major number</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> result;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>pr_info</span>(<span style=color:#e6db74>&#34;Device registered with major %d, minor %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, <span style=color:#a6e22e>MAJOR</span>(dev), <span style=color:#a6e22e>MINOR</span>(dev));
</span></span></code></pre></div><h4 id=2-initialize-and-register-the-device>2. Initialize and Register the Device:<a hidden class=anchor aria-hidden=true href=#2-initialize-and-register-the-device>#</a></h4><ul><li>Define a <code>cdev</code> structure and initialize it with file operations.</li><li>Use <code>cdev_add</code> to register the device with the kernel.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>struct</span> cdev my_cdev;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>cdev_init</span>(<span style=color:#f92672>&amp;</span>my_cdev, <span style=color:#f92672>&amp;</span>my_fops);
</span></span><span style=display:flex><span>my_cdev.owner <span style=color:#f92672>=</span> THIS_MODULE;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>result <span style=color:#f92672>=</span> <span style=color:#a6e22e>cdev_add</span>(<span style=color:#f92672>&amp;</span>my_cdev, dev, <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (result <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>pr_err</span>(<span style=color:#e6db74>&#34;Failed to add cdev</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>unregister_chrdev_region</span>(dev, <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> result;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=3-create-a-device-file-optional>3. Create a Device File (Optional):<a hidden class=anchor aria-hidden=true href=#3-create-a-device-file-optional>#</a></h4><ul><li>Creating a device file in <code>/dev</code> is optional because character devices can be accessed directly using their major and minor numbers through system calls or user-space libraries, bypassing the need for a device file. However, creating a file in <code>/dev</code> makes interaction more user-friendly by providing a standard interface.</li><li>To interact with a character device without creating a device file, you can use system calls like <code>mknod</code> to create a temporary device node or interact with the device directly using its major and minor numbers programmatically.</li><li>Use <code>class_create</code> and <code>device_create</code> to automatically create a device file in <code>/dev</code>.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>struct</span> class <span style=color:#f92672>*</span>my_class;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>my_class <span style=color:#f92672>=</span> <span style=color:#a6e22e>class_create</span>(THIS_MODULE, <span style=color:#e6db74>&#34;my_device_class&#34;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>IS_ERR</span>(my_class)) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>pr_err</span>(<span style=color:#e6db74>&#34;Failed to create class</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>cdev_del</span>(<span style=color:#f92672>&amp;</span>my_cdev);
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>unregister_chrdev_region</span>(dev, <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>PTR_ERR</span>(my_class);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>device_create</span>(my_class, NULL, dev, NULL, <span style=color:#e6db74>&#34;my_char_device&#34;</span>);
</span></span></code></pre></div><hr><h2 id=file-operations>File Operations<a hidden class=anchor aria-hidden=true href=#file-operations>#</a></h2><p>Character devices are controlled through a set of file operations defined in a <code>struct file_operations</code>. These operations determine how the device responds to system calls like <code>open</code>, <code>read</code>, <code>write</code>, and <code>ioctl</code>.</p><h4 id=1-define-file-operations>1. Define File Operations:<a hidden class=anchor aria-hidden=true href=#1-define-file-operations>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>ssize_t</span> <span style=color:#a6e22e>my_read</span>(<span style=color:#66d9ef>struct</span> file <span style=color:#f92672>*</span>file, <span style=color:#66d9ef>char</span> __user <span style=color:#f92672>*</span>buf, <span style=color:#66d9ef>size_t</span> len, <span style=color:#66d9ef>loff_t</span> <span style=color:#f92672>*</span>offset) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>char</span> data[] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Hello from kernel!</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>size_t</span> datalen <span style=color:#f92672>=</span> <span style=color:#a6e22e>strlen</span>(data);
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> (<span style=color:#f92672>*</span>offset <span style=color:#f92672>&gt;=</span> datalen)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> (len <span style=color:#f92672>&gt;</span> datalen <span style=color:#f92672>-</span> <span style=color:#f92672>*</span>offset)
</span></span><span style=display:flex><span>		len <span style=color:#f92672>=</span> datalen <span style=color:#f92672>-</span> <span style=color:#f92672>*</span>offset;
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>copy_to_user</span>(buf, data <span style=color:#f92672>+</span> <span style=color:#f92672>*</span>offset, len))
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span>EFAULT;
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	<span style=color:#f92672>*</span>offset <span style=color:#f92672>+=</span> len;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> len;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>ssize_t</span> <span style=color:#a6e22e>my_write</span>(<span style=color:#66d9ef>struct</span> file <span style=color:#f92672>*</span>file, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> __user <span style=color:#f92672>*</span>buf, <span style=color:#66d9ef>size_t</span> len, <span style=color:#66d9ef>loff_t</span> <span style=color:#f92672>*</span>offset) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>char</span> kbuf[<span style=color:#ae81ff>128</span>];
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> (len <span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>sizeof</span>(kbuf) <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>		len <span style=color:#f92672>=</span> <span style=color:#66d9ef>sizeof</span>(kbuf) <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>copy_from_user</span>(kbuf, buf, len))
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span>EFAULT;
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	kbuf[len] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;\0&#39;</span>;
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>pr_info</span>(<span style=color:#e6db74>&#34;Data from user: %s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, kbuf);
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> len;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>my_open</span>(<span style=color:#66d9ef>struct</span> inode <span style=color:#f92672>*</span>inode, <span style=color:#66d9ef>struct</span> file <span style=color:#f92672>*</span>file) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>pr_info</span>(<span style=color:#e6db74>&#34;Device opened</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>my_release</span>(<span style=color:#66d9ef>struct</span> inode <span style=color:#f92672>*</span>inode, <span style=color:#66d9ef>struct</span> file <span style=color:#f92672>*</span>file) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>pr_info</span>(<span style=color:#e6db74>&#34;Device closed</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>struct</span> file_operations my_fops <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>	.owner <span style=color:#f92672>=</span> THIS_MODULE,
</span></span><span style=display:flex><span>	.read <span style=color:#f92672>=</span> my_read,
</span></span><span style=display:flex><span>	.write <span style=color:#f92672>=</span> my_write,
</span></span><span style=display:flex><span>	.open <span style=color:#f92672>=</span> my_open,
</span></span><span style=display:flex><span>	.release <span style=color:#f92672>=</span> my_release,
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h4 id=2-explanation-of-generic-operations>2. Explanation of Generic Operations:<a hidden class=anchor aria-hidden=true href=#2-explanation-of-generic-operations>#</a></h4><ul><li><strong><code>open</code></strong>: Called when the device is accessed using <code>open()</code>. Used for initialization.</li><li><strong><code>release</code></strong>: Called when the device is closed.</li><li><strong><code>read</code></strong>: Transfers data from the kernel to user-space.</li><li><strong><code>write</code></strong>: Transfers data from user-space to the kernel.</li></ul><hr><h2 id=cleaning-up>Cleaning Up<a hidden class=anchor aria-hidden=true href=#cleaning-up>#</a></h2><p>When unloading the driver, release allocated resources:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> __exit <span style=color:#a6e22e>my_exit</span>(<span style=color:#66d9ef>void</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>device_destroy</span>(my_class, dev);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>class_destroy</span>(my_class);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>cdev_del</span>(<span style=color:#f92672>&amp;</span>my_cdev);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>unregister_chrdev_region</span>(dev, <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>pr_info</span>(<span style=color:#e6db74>&#34;Character device unregistered</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>module_exit</span>(my_exit);
</span></span></code></pre></div><hr><h2 id=example-user-space-interaction>Example User-Space Interaction<a hidden class=anchor aria-hidden=true href=#example-user-space-interaction>#</a></h2><p>Write a user-space program to interact with the character device:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;fcntl.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unistd.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> fd;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> buffer[<span style=color:#ae81ff>128</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    fd <span style=color:#f92672>=</span> <span style=color:#a6e22e>open</span>(<span style=color:#e6db74>&#34;/dev/my_char_device&#34;</span>, O_RDWR);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (fd <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>perror</span>(<span style=color:#e6db74>&#34;Failed to open device&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Write to device
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>write</span>(fd, <span style=color:#e6db74>&#34;Hello, kernel!&#34;</span>, <span style=color:#ae81ff>14</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Read from device
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>read</span>(fd, buffer, <span style=color:#66d9ef>sizeof</span>(buffer));
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Data from device: %s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, buffer);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>close</span>(fd);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><hr><h2 id=best-practices>Best Practices<a hidden class=anchor aria-hidden=true href=#best-practices>#</a></h2><ol><li><strong>Error Handling</strong>:<ul><li>Validate user input and handle edge cases.</li><li>Ensure proper cleanup in case of initialization failures.</li></ul></li><li><strong>Use Helper Functions</strong>:<ul><li>Use <code>alloc_chrdev_region</code> instead of hardcoding major numbers.</li><li><code>copy_to_user</code> and <code>copy_from_user</code> are essential for secure data exchange between kernel space and user space. These functions ensure that the kernel does not directly access user-space memory, which could lead to security risks and undefined behavior due to memory access violations. Instead, they provide controlled, validated mechanisms for copying data. Alternatively, functions like <code>memdup_user</code> can be used when copying large blocks of data into kernel space. These methods ensure safe interaction between different memory domains, protecting system stability.</li></ul></li><li><strong>Device Permissions</strong>:<ul><li>Set appropriate file permissions on the device file to avoid unauthorized access.</li></ul></li><li><strong>Documentation</strong>:<ul><li>Provide clear documentation for user-space developers on how to interact with the device.</li></ul></li></ol></div><footer class=post-footer><ul class=post-tags><li><a href=https://rishav-singh-0.github.io/tags/platform/drivers/>Platform/Drivers</a></li></ul><nav class=paginav><a class=prev href=https://rishav-singh-0.github.io/posts/device-tree-dt-in-linux-kernel/><span class=title>« Prev</span><br><span>Device Tree (DT) in Linux Kernel</span>
</a><a class=next href=https://rishav-singh-0.github.io/posts/ioctl-in-kernel-device-drivers/><span class=title>Next »</span><br><span>IOCTL in Kernel Device Drivers</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://rishav-singh-0.github.io/>Rishav's Digital Garden</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>