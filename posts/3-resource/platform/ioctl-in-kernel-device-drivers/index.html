<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>IOCTL in Kernel Device Drivers | Rishav's Digital Garden</title><meta name=keywords content="Platform/Drivers"><meta name=description content='ioctl Implementation in Kernel Device Drivers
Overview
ioctl (Input/Output Control) is a powerful system call in Linux used to perform device-specific operations that are not covered by standard system calls like read, write, or open. It allows user-space applications to interact with kernel-space drivers for device-specific configurations and data exchanges.

How ioctl Works
1. User-Space Interaction:

A user-space application invokes ioctl using the following prototype:

int ioctl(int fd, unsigned long cmd, void *arg);

fd: File descriptor for the device.
cmd: Command defining the operation.
arg: Pointer to the data or argument passed between user-space and kernel-space.

2. Driver-Side Handling:

The ioctl system call is routed to the driver by the kernel.
The driver implements a specific unlocked_ioctl or compat_ioctl callback in the file_operations structure.

3. Data Flow:

Arguments passed via arg can be pointers to user-space data, requiring the driver to use helper functions like copy_from_user and copy_to_user for secure data transfer.


Steps to Implement ioctl in a Kernel Driver
1. Define ioctl Commands:

Use macros to define command numbers, typically with the _IO, _IOR, _IOW, and _IOWR macros provided in <linux/ioctl.h>.

#define MY_IOCTL_BASE &#39;M&#39;
#define IOCTL_CMD_GET _IOR(MY_IOCTL_BASE, 1, int)
#define IOCTL_CMD_SET _IOW(MY_IOCTL_BASE, 2, int)

_IOR: Read data from the kernel.
_IOW: Write data to the kernel.
_IOWR: Read and write data.
_IO: Command without data.

2. Implement ioctl Callback:

Define the unlocked_ioctl function in the driver.
Handle commands appropriately based on cmd.

static long my_ioctl(struct file *file, unsigned int cmd, unsigned long arg) {
	int value;

	switch (cmd) {
		case IOCTL_CMD_GET:
			value = 1234; // Example value
			if (copy_to_user((int __user *)arg, &amp;value, sizeof(value)))
				return -EFAULT;
			break;

		case IOCTL_CMD_SET:
			if (copy_from_user(&amp;value, (int __user *)arg, sizeof(value)))
				return -EFAULT;
			pr_info("Value set by user: %d\n", value);
			break;

		default:
			return -ENOTTY; // Command not supported
	}
	return 0;
}
3. Integrate into file_operations:

Register the ioctl handler in the file_operations structure.

static const struct file_operations my_fops = {
	.owner = THIS_MODULE,
	.open = my_open,
	.release = my_release,
	.unlocked_ioctl = my_ioctl,
};
4. Test the ioctl Implementation:

Write a user-space application to interact with the driver.

#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/ioctl.h>

#define MY_IOCTL_BASE &#39;M&#39;
#define IOCTL_CMD_GET _IOR(MY_IOCTL_BASE, 1, int)
#define IOCTL_CMD_SET _IOW(MY_IOCTL_BASE, 2, int)

int main() {
	int fd, value = 42;

	fd = open("/dev/my_device", O_RDWR);
	if (fd < 0) {
		perror("Failed to open device");
		return -1;
	}

	if (ioctl(fd, IOCTL_CMD_SET, &amp;value) < 0) {
		perror("ioctl SET failed");
	}

	if (ioctl(fd, IOCTL_CMD_GET, &amp;value) < 0) {
		perror("ioctl GET failed");
	} else {
		printf("Value from device: %d\n", value);
	}

	close(fd);
	return 0;
}

Best Practices for ioctl

Use Explicit Command Definitions:

Follow a consistent naming convention for command macros.


Secure User-Kernel Data Transfer:

Always validate pointers and sizes.
Use copy_from_user and copy_to_user for safe data exchange.


Error Handling:

Return appropriate error codes for unsupported commands or invalid inputs.


Limit ioctl Usage:

Avoid using ioctl for operations that can be implemented using read or write.


Magic Number: Ensure it’s unique (check Documentation/ioctl/ioctl-number.txt in kernel sources).
Atomicity: Use locks if hardware operations are not atomic.
Cross-Platform: Handle 32/64-bit compatibility with compat_ioctl if needed.


Real-World Example: Custom ARM Board
For a custom ARM board, you might need an ioctl to configure hardware parameters like GPIO modes or clock frequencies.'><meta name=author content><link rel=canonical href=https://blog.rishavs.in/posts/3-resource/platform/ioctl-in-kernel-device-drivers/><link crossorigin=anonymous href=/assets/css/stylesheet.93f625d739f1d6a5c6f20c146bc6a8d26b233492b34b2220c54b12fd46a04ded.css integrity="sha256-k/Yl1znx1qXG8gwUa8ao0msjNJKzSyIgxUsS/UagTe0=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.rishavs.in/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.rishavs.in/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.rishavs.in/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.rishavs.in/apple-touch-icon.png><link rel=mask-icon href=https://blog.rishavs.in/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://blog.rishavs.in/posts/3-resource/platform/ioctl-in-kernel-device-drivers/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://blog.rishavs.in/posts/3-resource/platform/ioctl-in-kernel-device-drivers/"><meta property="og:site_name" content="Rishav's Digital Garden"><meta property="og:title" content="IOCTL in Kernel Device Drivers"><meta property="og:description" content='ioctl Implementation in Kernel Device Drivers Overview ioctl (Input/Output Control) is a powerful system call in Linux used to perform device-specific operations that are not covered by standard system calls like read, write, or open. It allows user-space applications to interact with kernel-space drivers for device-specific configurations and data exchanges.
How ioctl Works 1. User-Space Interaction: A user-space application invokes ioctl using the following prototype: int ioctl(int fd, unsigned long cmd, void *arg); fd: File descriptor for the device. cmd: Command defining the operation. arg: Pointer to the data or argument passed between user-space and kernel-space. 2. Driver-Side Handling: The ioctl system call is routed to the driver by the kernel. The driver implements a specific unlocked_ioctl or compat_ioctl callback in the file_operations structure. 3. Data Flow: Arguments passed via arg can be pointers to user-space data, requiring the driver to use helper functions like copy_from_user and copy_to_user for secure data transfer. Steps to Implement ioctl in a Kernel Driver 1. Define ioctl Commands: Use macros to define command numbers, typically with the _IO, _IOR, _IOW, and _IOWR macros provided in <linux/ioctl.h>. #define MY_IOCTL_BASE &#39;M&#39; #define IOCTL_CMD_GET _IOR(MY_IOCTL_BASE, 1, int) #define IOCTL_CMD_SET _IOW(MY_IOCTL_BASE, 2, int) _IOR: Read data from the kernel. _IOW: Write data to the kernel. _IOWR: Read and write data. _IO: Command without data. 2. Implement ioctl Callback: Define the unlocked_ioctl function in the driver. Handle commands appropriately based on cmd. static long my_ioctl(struct file *file, unsigned int cmd, unsigned long arg) { int value; switch (cmd) { case IOCTL_CMD_GET: value = 1234; // Example value if (copy_to_user((int __user *)arg, &amp;value, sizeof(value))) return -EFAULT; break; case IOCTL_CMD_SET: if (copy_from_user(&amp;value, (int __user *)arg, sizeof(value))) return -EFAULT; pr_info("Value set by user: %d\n", value); break; default: return -ENOTTY; // Command not supported } return 0; } 3. Integrate into file_operations: Register the ioctl handler in the file_operations structure. static const struct file_operations my_fops = { .owner = THIS_MODULE, .open = my_open, .release = my_release, .unlocked_ioctl = my_ioctl, }; 4. Test the ioctl Implementation: Write a user-space application to interact with the driver. #include <stdio.h> #include <fcntl.h> #include <unistd.h> #include <sys/ioctl.h> #define MY_IOCTL_BASE &#39;M&#39; #define IOCTL_CMD_GET _IOR(MY_IOCTL_BASE, 1, int) #define IOCTL_CMD_SET _IOW(MY_IOCTL_BASE, 2, int) int main() { int fd, value = 42; fd = open("/dev/my_device", O_RDWR); if (fd < 0) { perror("Failed to open device"); return -1; } if (ioctl(fd, IOCTL_CMD_SET, &amp;value) < 0) { perror("ioctl SET failed"); } if (ioctl(fd, IOCTL_CMD_GET, &amp;value) < 0) { perror("ioctl GET failed"); } else { printf("Value from device: %d\n", value); } close(fd); return 0; } Best Practices for ioctl Use Explicit Command Definitions: Follow a consistent naming convention for command macros. Secure User-Kernel Data Transfer: Always validate pointers and sizes. Use copy_from_user and copy_to_user for safe data exchange. Error Handling: Return appropriate error codes for unsupported commands or invalid inputs. Limit ioctl Usage: Avoid using ioctl for operations that can be implemented using read or write. Magic Number: Ensure it’s unique (check Documentation/ioctl/ioctl-number.txt in kernel sources). Atomicity: Use locks if hardware operations are not atomic. Cross-Platform: Handle 32/64-bit compatibility with compat_ioctl if needed. Real-World Example: Custom ARM Board For a custom ARM board, you might need an ioctl to configure hardware parameters like GPIO modes or clock frequencies.'><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-01-24T17:24:00+00:00"><meta property="article:modified_time" content="2025-01-24T17:24:00+00:00"><meta property="article:tag" content="Platform/Drivers"><meta name=twitter:card content="summary"><meta name=twitter:title content="IOCTL in Kernel Device Drivers"><meta name=twitter:description content='ioctl Implementation in Kernel Device Drivers
Overview
ioctl (Input/Output Control) is a powerful system call in Linux used to perform device-specific operations that are not covered by standard system calls like read, write, or open. It allows user-space applications to interact with kernel-space drivers for device-specific configurations and data exchanges.

How ioctl Works
1. User-Space Interaction:

A user-space application invokes ioctl using the following prototype:

int ioctl(int fd, unsigned long cmd, void *arg);

fd: File descriptor for the device.
cmd: Command defining the operation.
arg: Pointer to the data or argument passed between user-space and kernel-space.

2. Driver-Side Handling:

The ioctl system call is routed to the driver by the kernel.
The driver implements a specific unlocked_ioctl or compat_ioctl callback in the file_operations structure.

3. Data Flow:

Arguments passed via arg can be pointers to user-space data, requiring the driver to use helper functions like copy_from_user and copy_to_user for secure data transfer.


Steps to Implement ioctl in a Kernel Driver
1. Define ioctl Commands:

Use macros to define command numbers, typically with the _IO, _IOR, _IOW, and _IOWR macros provided in <linux/ioctl.h>.

#define MY_IOCTL_BASE &#39;M&#39;
#define IOCTL_CMD_GET _IOR(MY_IOCTL_BASE, 1, int)
#define IOCTL_CMD_SET _IOW(MY_IOCTL_BASE, 2, int)

_IOR: Read data from the kernel.
_IOW: Write data to the kernel.
_IOWR: Read and write data.
_IO: Command without data.

2. Implement ioctl Callback:

Define the unlocked_ioctl function in the driver.
Handle commands appropriately based on cmd.

static long my_ioctl(struct file *file, unsigned int cmd, unsigned long arg) {
	int value;

	switch (cmd) {
		case IOCTL_CMD_GET:
			value = 1234; // Example value
			if (copy_to_user((int __user *)arg, &amp;value, sizeof(value)))
				return -EFAULT;
			break;

		case IOCTL_CMD_SET:
			if (copy_from_user(&amp;value, (int __user *)arg, sizeof(value)))
				return -EFAULT;
			pr_info("Value set by user: %d\n", value);
			break;

		default:
			return -ENOTTY; // Command not supported
	}
	return 0;
}
3. Integrate into file_operations:

Register the ioctl handler in the file_operations structure.

static const struct file_operations my_fops = {
	.owner = THIS_MODULE,
	.open = my_open,
	.release = my_release,
	.unlocked_ioctl = my_ioctl,
};
4. Test the ioctl Implementation:

Write a user-space application to interact with the driver.

#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/ioctl.h>

#define MY_IOCTL_BASE &#39;M&#39;
#define IOCTL_CMD_GET _IOR(MY_IOCTL_BASE, 1, int)
#define IOCTL_CMD_SET _IOW(MY_IOCTL_BASE, 2, int)

int main() {
	int fd, value = 42;

	fd = open("/dev/my_device", O_RDWR);
	if (fd < 0) {
		perror("Failed to open device");
		return -1;
	}

	if (ioctl(fd, IOCTL_CMD_SET, &amp;value) < 0) {
		perror("ioctl SET failed");
	}

	if (ioctl(fd, IOCTL_CMD_GET, &amp;value) < 0) {
		perror("ioctl GET failed");
	} else {
		printf("Value from device: %d\n", value);
	}

	close(fd);
	return 0;
}

Best Practices for ioctl

Use Explicit Command Definitions:

Follow a consistent naming convention for command macros.


Secure User-Kernel Data Transfer:

Always validate pointers and sizes.
Use copy_from_user and copy_to_user for safe data exchange.


Error Handling:

Return appropriate error codes for unsupported commands or invalid inputs.


Limit ioctl Usage:

Avoid using ioctl for operations that can be implemented using read or write.


Magic Number: Ensure it’s unique (check Documentation/ioctl/ioctl-number.txt in kernel sources).
Atomicity: Use locks if hardware operations are not atomic.
Cross-Platform: Handle 32/64-bit compatibility with compat_ioctl if needed.


Real-World Example: Custom ARM Board
For a custom ARM board, you might need an ioctl to configure hardware parameters like GPIO modes or clock frequencies.'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.rishavs.in/posts/"},{"@type":"ListItem","position":2,"name":"IOCTL in Kernel Device Drivers","item":"https://blog.rishavs.in/posts/3-resource/platform/ioctl-in-kernel-device-drivers/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"IOCTL in Kernel Device Drivers","name":"IOCTL in Kernel Device Drivers","description":"ioctl Implementation in Kernel Device Drivers Overview ioctl (Input/Output Control) is a powerful system call in Linux used to perform device-specific operations that are not covered by standard system calls like read, write, or open. It allows user-space applications to interact with kernel-space drivers for device-specific configurations and data exchanges.\nHow ioctl Works 1. User-Space Interaction: A user-space application invokes ioctl using the following prototype: int ioctl(int fd, unsigned long cmd, void *arg); fd: File descriptor for the device. cmd: Command defining the operation. arg: Pointer to the data or argument passed between user-space and kernel-space. 2. Driver-Side Handling: The ioctl system call is routed to the driver by the kernel. The driver implements a specific unlocked_ioctl or compat_ioctl callback in the file_operations structure. 3. Data Flow: Arguments passed via arg can be pointers to user-space data, requiring the driver to use helper functions like copy_from_user and copy_to_user for secure data transfer. Steps to Implement ioctl in a Kernel Driver 1. Define ioctl Commands: Use macros to define command numbers, typically with the _IO, _IOR, _IOW, and _IOWR macros provided in \u0026lt;linux/ioctl.h\u0026gt;. #define MY_IOCTL_BASE \u0026#39;M\u0026#39; #define IOCTL_CMD_GET _IOR(MY_IOCTL_BASE, 1, int) #define IOCTL_CMD_SET _IOW(MY_IOCTL_BASE, 2, int) _IOR: Read data from the kernel. _IOW: Write data to the kernel. _IOWR: Read and write data. _IO: Command without data. 2. Implement ioctl Callback: Define the unlocked_ioctl function in the driver. Handle commands appropriately based on cmd. static long my_ioctl(struct file *file, unsigned int cmd, unsigned long arg) { int value; switch (cmd) { case IOCTL_CMD_GET: value = 1234; // Example value if (copy_to_user((int __user *)arg, \u0026amp;value, sizeof(value))) return -EFAULT; break; case IOCTL_CMD_SET: if (copy_from_user(\u0026amp;value, (int __user *)arg, sizeof(value))) return -EFAULT; pr_info(\u0026#34;Value set by user: %d\\n\u0026#34;, value); break; default: return -ENOTTY; // Command not supported } return 0; } 3. Integrate into file_operations: Register the ioctl handler in the file_operations structure. static const struct file_operations my_fops = { .owner = THIS_MODULE, .open = my_open, .release = my_release, .unlocked_ioctl = my_ioctl, }; 4. Test the ioctl Implementation: Write a user-space application to interact with the driver. #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/ioctl.h\u0026gt; #define MY_IOCTL_BASE \u0026#39;M\u0026#39; #define IOCTL_CMD_GET _IOR(MY_IOCTL_BASE, 1, int) #define IOCTL_CMD_SET _IOW(MY_IOCTL_BASE, 2, int) int main() { int fd, value = 42; fd = open(\u0026#34;/dev/my_device\u0026#34;, O_RDWR); if (fd \u0026lt; 0) { perror(\u0026#34;Failed to open device\u0026#34;); return -1; } if (ioctl(fd, IOCTL_CMD_SET, \u0026amp;value) \u0026lt; 0) { perror(\u0026#34;ioctl SET failed\u0026#34;); } if (ioctl(fd, IOCTL_CMD_GET, \u0026amp;value) \u0026lt; 0) { perror(\u0026#34;ioctl GET failed\u0026#34;); } else { printf(\u0026#34;Value from device: %d\\n\u0026#34;, value); } close(fd); return 0; } Best Practices for ioctl Use Explicit Command Definitions: Follow a consistent naming convention for command macros. Secure User-Kernel Data Transfer: Always validate pointers and sizes. Use copy_from_user and copy_to_user for safe data exchange. Error Handling: Return appropriate error codes for unsupported commands or invalid inputs. Limit ioctl Usage: Avoid using ioctl for operations that can be implemented using read or write. Magic Number: Ensure it’s unique (check Documentation/ioctl/ioctl-number.txt in kernel sources). Atomicity: Use locks if hardware operations are not atomic. Cross-Platform: Handle 32/64-bit compatibility with compat_ioctl if needed. Real-World Example: Custom ARM Board For a custom ARM board, you might need an ioctl to configure hardware parameters like GPIO modes or clock frequencies.\n","keywords":["Platform/Drivers"],"articleBody":"ioctl Implementation in Kernel Device Drivers Overview ioctl (Input/Output Control) is a powerful system call in Linux used to perform device-specific operations that are not covered by standard system calls like read, write, or open. It allows user-space applications to interact with kernel-space drivers for device-specific configurations and data exchanges.\nHow ioctl Works 1. User-Space Interaction: A user-space application invokes ioctl using the following prototype: int ioctl(int fd, unsigned long cmd, void *arg); fd: File descriptor for the device. cmd: Command defining the operation. arg: Pointer to the data or argument passed between user-space and kernel-space. 2. Driver-Side Handling: The ioctl system call is routed to the driver by the kernel. The driver implements a specific unlocked_ioctl or compat_ioctl callback in the file_operations structure. 3. Data Flow: Arguments passed via arg can be pointers to user-space data, requiring the driver to use helper functions like copy_from_user and copy_to_user for secure data transfer. Steps to Implement ioctl in a Kernel Driver 1. Define ioctl Commands: Use macros to define command numbers, typically with the _IO, _IOR, _IOW, and _IOWR macros provided in . #define MY_IOCTL_BASE 'M' #define IOCTL_CMD_GET _IOR(MY_IOCTL_BASE, 1, int) #define IOCTL_CMD_SET _IOW(MY_IOCTL_BASE, 2, int) _IOR: Read data from the kernel. _IOW: Write data to the kernel. _IOWR: Read and write data. _IO: Command without data. 2. Implement ioctl Callback: Define the unlocked_ioctl function in the driver. Handle commands appropriately based on cmd. static long my_ioctl(struct file *file, unsigned int cmd, unsigned long arg) { int value; switch (cmd) { case IOCTL_CMD_GET: value = 1234; // Example value if (copy_to_user((int __user *)arg, \u0026value, sizeof(value))) return -EFAULT; break; case IOCTL_CMD_SET: if (copy_from_user(\u0026value, (int __user *)arg, sizeof(value))) return -EFAULT; pr_info(\"Value set by user: %d\\n\", value); break; default: return -ENOTTY; // Command not supported } return 0; } 3. Integrate into file_operations: Register the ioctl handler in the file_operations structure. static const struct file_operations my_fops = { .owner = THIS_MODULE, .open = my_open, .release = my_release, .unlocked_ioctl = my_ioctl, }; 4. Test the ioctl Implementation: Write a user-space application to interact with the driver. #include #include #include #include #define MY_IOCTL_BASE 'M' #define IOCTL_CMD_GET _IOR(MY_IOCTL_BASE, 1, int) #define IOCTL_CMD_SET _IOW(MY_IOCTL_BASE, 2, int) int main() { int fd, value = 42; fd = open(\"/dev/my_device\", O_RDWR); if (fd \u003c 0) { perror(\"Failed to open device\"); return -1; } if (ioctl(fd, IOCTL_CMD_SET, \u0026value) \u003c 0) { perror(\"ioctl SET failed\"); } if (ioctl(fd, IOCTL_CMD_GET, \u0026value) \u003c 0) { perror(\"ioctl GET failed\"); } else { printf(\"Value from device: %d\\n\", value); } close(fd); return 0; } Best Practices for ioctl Use Explicit Command Definitions: Follow a consistent naming convention for command macros. Secure User-Kernel Data Transfer: Always validate pointers and sizes. Use copy_from_user and copy_to_user for safe data exchange. Error Handling: Return appropriate error codes for unsupported commands or invalid inputs. Limit ioctl Usage: Avoid using ioctl for operations that can be implemented using read or write. Magic Number: Ensure it’s unique (check Documentation/ioctl/ioctl-number.txt in kernel sources). Atomicity: Use locks if hardware operations are not atomic. Cross-Platform: Handle 32/64-bit compatibility with compat_ioctl if needed. Real-World Example: Custom ARM Board For a custom ARM board, you might need an ioctl to configure hardware parameters like GPIO modes or clock frequencies.\nCommand Definitions: #define GPIO_BASE 'G' #define IOCTL_GPIO_CONFIG _IOW(GPIO_BASE, 1, struct gpio_config) #define IOCTL_GPIO_READ _IOR(GPIO_BASE, 2, int) Example ioctl Implementation: struct gpio_config { int pin; int mode; // 0: Input, 1: Output }; static long gpio_ioctl(struct file *file, unsigned int cmd, unsigned long arg) { struct gpio_config config; switch (cmd) { case IOCTL_GPIO_CONFIG: if (copy_from_user(\u0026config, (struct gpio_config __user *)arg, sizeof(config))) return -EFAULT; pr_info(\"Configuring GPIO pin %d as %s\\n\", config.pin, config.mode ? \"Output\" : \"Input\"); // Add hardware configuration logic here break; case IOCTL_GPIO_READ: // Example: Return the state of a pin int state = 1; // Assume pin is high if (copy_to_user((int __user *)arg, \u0026state, sizeof(state))) return -EFAULT; break; default: return -ENOTTY; } return 0; } By implementing ioctl like this, you provide user-space applications with a mechanism to interact with custom device-specific features efficiently.\n","wordCount":"667","inLanguage":"en","datePublished":"2025-01-24T17:24:00Z","dateModified":"2025-01-24T17:24:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.rishavs.in/posts/3-resource/platform/ioctl-in-kernel-device-drivers/"},"publisher":{"@type":"Organization","name":"Rishav's Digital Garden","logo":{"@type":"ImageObject","url":"https://blog.rishavs.in/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.rishavs.in/ accesskey=h title="Rishav's Digital Garden (Alt + H)">Rishav's Digital Garden</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.rishavs.in/archives title=Archive><span>Archive</span></a></li><li><a href=https://blog.rishavs.in/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://blog.rishavs.in/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">IOCTL in Kernel Device Drivers</h1><div class=post-meta><span title='2025-01-24 17:24:00 +0000 UTC'>January 24, 2025</span>&nbsp;·&nbsp;4 min</div></header><div class=post-content><h2 id=ioctl-implementation-in-kernel-device-drivers>ioctl Implementation in Kernel Device Drivers<a hidden class=anchor aria-hidden=true href=#ioctl-implementation-in-kernel-device-drivers>#</a></h2><h2 id=overview>Overview<a hidden class=anchor aria-hidden=true href=#overview>#</a></h2><p><code>ioctl</code> (Input/Output Control) is a powerful system call in Linux used to perform device-specific operations that are not covered by standard system calls like <code>read</code>, <code>write</code>, or <code>open</code>. It allows user-space applications to interact with kernel-space drivers for device-specific configurations and data exchanges.</p><hr><h2 id=how-ioctl-works>How ioctl Works<a hidden class=anchor aria-hidden=true href=#how-ioctl-works>#</a></h2><h4 id=1-user-space-interaction>1. User-Space Interaction:<a hidden class=anchor aria-hidden=true href=#1-user-space-interaction>#</a></h4><ul><li>A user-space application invokes <code>ioctl</code> using the following prototype:</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>ioctl</span>(<span style=color:#66d9ef>int</span> fd, <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> cmd, <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>arg);
</span></span></code></pre></div><ul><li><code>fd</code>: File descriptor for the device.</li><li><code>cmd</code>: Command defining the operation.</li><li><code>arg</code>: Pointer to the data or argument passed between user-space and kernel-space.</li></ul><h4 id=2-driver-side-handling>2. Driver-Side Handling:<a hidden class=anchor aria-hidden=true href=#2-driver-side-handling>#</a></h4><ul><li>The <code>ioctl</code> system call is routed to the driver by the kernel.</li><li>The driver implements a specific <code>unlocked_ioctl</code> or <code>compat_ioctl</code> callback in the <code>file_operations</code> structure.</li></ul><h4 id=3-data-flow>3. Data Flow:<a hidden class=anchor aria-hidden=true href=#3-data-flow>#</a></h4><ul><li>Arguments passed via <code>arg</code> can be pointers to user-space data, requiring the driver to use helper functions like <code>copy_from_user</code> and <code>copy_to_user</code> for secure data transfer.</li></ul><hr><h2 id=steps-to-implement-ioctl-in-a-kernel-driver>Steps to Implement ioctl in a Kernel Driver<a hidden class=anchor aria-hidden=true href=#steps-to-implement-ioctl-in-a-kernel-driver>#</a></h2><h4 id=1-define-ioctl-commands>1. Define ioctl Commands:<a hidden class=anchor aria-hidden=true href=#1-define-ioctl-commands>#</a></h4><ul><li>Use macros to define command numbers, typically with the <code>_IO</code>, <code>_IOR</code>, <code>_IOW</code>, and <code>_IOWR</code> macros provided in <code>&lt;linux/ioctl.h></code>.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#define MY_IOCTL_BASE &#39;M&#39;
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define IOCTL_CMD_GET _IOR(MY_IOCTL_BASE, 1, int)
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define IOCTL_CMD_SET _IOW(MY_IOCTL_BASE, 2, int)
</span></span></span></code></pre></div><ul><li><code>_IOR</code>: Read data from the kernel.</li><li><code>_IOW</code>: Write data to the kernel.</li><li><code>_IOWR</code>: Read and write data.</li><li><code>_IO</code>: Command without data.</li></ul><h4 id=2-implement-ioctl-callback>2. Implement ioctl Callback:<a hidden class=anchor aria-hidden=true href=#2-implement-ioctl-callback>#</a></h4><ul><li>Define the <code>unlocked_ioctl</code> function in the driver.</li><li>Handle commands appropriately based on <code>cmd</code>.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>long</span> <span style=color:#a6e22e>my_ioctl</span>(<span style=color:#66d9ef>struct</span> file <span style=color:#f92672>*</span>file, <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> cmd, <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> arg) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span> value;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>switch</span> (cmd) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>case</span> IOCTL_CMD_GET:
</span></span><span style=display:flex><span>			value <span style=color:#f92672>=</span> <span style=color:#ae81ff>1234</span>; <span style=color:#75715e>// Example value
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>copy_to_user</span>((<span style=color:#66d9ef>int</span> __user <span style=color:#f92672>*</span>)arg, <span style=color:#f92672>&amp;</span>value, <span style=color:#66d9ef>sizeof</span>(value)))
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span>EFAULT;
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>case</span> IOCTL_CMD_SET:
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>copy_from_user</span>(<span style=color:#f92672>&amp;</span>value, (<span style=color:#66d9ef>int</span> __user <span style=color:#f92672>*</span>)arg, <span style=color:#66d9ef>sizeof</span>(value)))
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span>EFAULT;
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>pr_info</span>(<span style=color:#e6db74>&#34;Value set by user: %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, value);
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>default</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span>ENOTTY; <span style=color:#75715e>// Command not supported
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=3-integrate-into-file_operations>3. Integrate into file_operations:<a hidden class=anchor aria-hidden=true href=#3-integrate-into-file_operations>#</a></h4><ul><li>Register the ioctl handler in the <code>file_operations</code> structure.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>struct</span> file_operations my_fops <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>	.owner <span style=color:#f92672>=</span> THIS_MODULE,
</span></span><span style=display:flex><span>	.open <span style=color:#f92672>=</span> my_open,
</span></span><span style=display:flex><span>	.release <span style=color:#f92672>=</span> my_release,
</span></span><span style=display:flex><span>	.unlocked_ioctl <span style=color:#f92672>=</span> my_ioctl,
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h4 id=4-test-the-ioctl-implementation>4. Test the ioctl Implementation:<a hidden class=anchor aria-hidden=true href=#4-test-the-ioctl-implementation>#</a></h4><ul><li>Write a user-space application to interact with the driver.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;fcntl.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unistd.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/ioctl.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define MY_IOCTL_BASE &#39;M&#39;
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define IOCTL_CMD_GET _IOR(MY_IOCTL_BASE, 1, int)
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define IOCTL_CMD_SET _IOW(MY_IOCTL_BASE, 2, int)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span> fd, value <span style=color:#f92672>=</span> <span style=color:#ae81ff>42</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	fd <span style=color:#f92672>=</span> <span style=color:#a6e22e>open</span>(<span style=color:#e6db74>&#34;/dev/my_device&#34;</span>, O_RDWR);
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> (fd <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>perror</span>(<span style=color:#e6db74>&#34;Failed to open device&#34;</span>);
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>ioctl</span>(fd, IOCTL_CMD_SET, <span style=color:#f92672>&amp;</span>value) <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>perror</span>(<span style=color:#e6db74>&#34;ioctl SET failed&#34;</span>);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>ioctl</span>(fd, IOCTL_CMD_GET, <span style=color:#f92672>&amp;</span>value) <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>perror</span>(<span style=color:#e6db74>&#34;ioctl GET failed&#34;</span>);
</span></span><span style=display:flex><span>	} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Value from device: %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, value);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>close</span>(fd);
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><hr><h2 id=best-practices-for-ioctl>Best Practices for ioctl<a hidden class=anchor aria-hidden=true href=#best-practices-for-ioctl>#</a></h2><ol><li><strong>Use Explicit Command Definitions</strong>:<ul><li>Follow a consistent naming convention for command macros.</li></ul></li><li><strong>Secure User-Kernel Data Transfer</strong>:<ul><li>Always validate pointers and sizes.</li><li>Use <code>copy_from_user</code> and <code>copy_to_user</code> for safe data exchange.</li></ul></li><li><strong>Error Handling</strong>:<ul><li>Return appropriate error codes for unsupported commands or invalid inputs.</li></ul></li><li><strong>Limit ioctl Usage</strong>:<ul><li>Avoid using <code>ioctl</code> for operations that can be implemented using <code>read</code> or <code>write</code>.</li></ul></li><li><strong>Magic Number</strong>: Ensure it’s unique (check <code>Documentation/ioctl/ioctl-number.txt</code> in kernel sources).</li><li><strong>Atomicity</strong>: Use locks if hardware operations are not atomic.</li><li><strong>Cross-Platform</strong>: Handle 32/64-bit compatibility with <code>compat_ioctl</code> if needed.</li></ol><hr><h2 id=real-world-example-custom-arm-board>Real-World Example: Custom ARM Board<a hidden class=anchor aria-hidden=true href=#real-world-example-custom-arm-board>#</a></h2><p>For a custom ARM board, you might need an <code>ioctl</code> to configure hardware parameters like GPIO modes or clock frequencies.</p><h4 id=command-definitions>Command Definitions:<a hidden class=anchor aria-hidden=true href=#command-definitions>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#define GPIO_BASE &#39;G&#39;
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define IOCTL_GPIO_CONFIG _IOW(GPIO_BASE, 1, struct gpio_config)
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define IOCTL_GPIO_READ _IOR(GPIO_BASE, 2, int)
</span></span></span></code></pre></div><h4 id=example-ioctl-implementation>Example ioctl Implementation:<a hidden class=anchor aria-hidden=true href=#example-ioctl-implementation>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>struct</span> gpio_config {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> pin;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> mode; <span style=color:#75715e>// 0: Input, 1: Output
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>long</span> <span style=color:#a6e22e>gpio_ioctl</span>(<span style=color:#66d9ef>struct</span> file <span style=color:#f92672>*</span>file, <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> cmd, <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> arg) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> gpio_config config;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>switch</span> (cmd) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> IOCTL_GPIO_CONFIG:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>copy_from_user</span>(<span style=color:#f92672>&amp;</span>config, (<span style=color:#66d9ef>struct</span> gpio_config __user <span style=color:#f92672>*</span>)arg, <span style=color:#66d9ef>sizeof</span>(config)))
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span>EFAULT;
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>pr_info</span>(<span style=color:#e6db74>&#34;Configuring GPIO pin %d as %s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, config.pin, config.mode <span style=color:#f92672>?</span> <span style=color:#e6db74>&#34;Output&#34;</span> <span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;Input&#34;</span>);
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Add hardware configuration logic here
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> IOCTL_GPIO_READ:
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Example: Return the state of a pin
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>int</span> state <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; <span style=color:#75715e>// Assume pin is high
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>copy_to_user</span>((<span style=color:#66d9ef>int</span> __user <span style=color:#f92672>*</span>)arg, <span style=color:#f92672>&amp;</span>state, <span style=color:#66d9ef>sizeof</span>(state)))
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span>EFAULT;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>default</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span>ENOTTY;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>By implementing <code>ioctl</code> like this, you provide user-space applications with a mechanism to interact with custom device-specific features efficiently.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.rishavs.in/tags/platform/drivers/>Platform/Drivers</a></li></ul><nav class=paginav><a class=prev href=https://blog.rishavs.in/posts/3-resource/platform/character-device-management-in-kernel-drivers/><span class=title>« Prev</span><br><span>Character Device Management in Kernel Drivers</span>
</a><a class=next href=https://blog.rishavs.in/posts/0-inbox/ssl-certificate/><span class=title>Next »</span><br><span>SSL Certificate</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://blog.rishavs.in/>Rishav's Digital Garden</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>