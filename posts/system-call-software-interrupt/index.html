<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>System Call (Software Interrupt) | Rishav's Digital Garden</title>
<meta name=keywords content="OS/Interrupt,Platform/Drivers"><meta name=description content='1. System Call Basics
System calls (syscalls) are the interface for user-space programs to request services from the kernel. Examples include:

File I/O: read(), write(), open(), close().
Device Control: ioctl().
Signal Handling: kill(), signal().


2. System Call Table and Registration
Syscall Table:

A table (sys_call_table) maps syscall numbers to handler functions.
Architecture-Specific:

x86: Defined in arch/x86/entry/syscalls/syscall_64.tbl.
ARM: Defined in arch/arm/tools/syscall.tbl.


Registration:

Syscalls are registered at compile time using macros like SYSCALL_DEFINE (e.g., SYSCALL_DEFINE3(write, ...) for write()).
For custom syscalls (rare and discouraged), you would:

Add an entry to the syscall table.
Define the handler using SYSCALL_DEFINE.
Recompile the kernel (or use modules for dynamic insertion).






3. Flow of System Calls
1. User-Space Invocation

The libc wrapper (e.g., read(), ioctl()) triggers a software interrupt (int 0x80 on x86) or uses the syscall instruction (modern x86/ARM).

// User-space code
fd = open("/dev/mydevice", O_RDWR);  // Syscall 1: open()
read(fd, buf, 100);                  // Syscall 2: read()
ioctl(fd, MY_CMD, arg);              // Syscall 3: ioctl()
close(fd);                           // Syscall 4: close()
2. Transition to Kernel Mode

Switches to kernel mode (ring 0 on x86, EL1 on ARM).
Saves user-space registers (e.g., RIP, RSP, EFLAGS).
Jumps to the kernel&rsquo;s syscall entry point (e.g., entry_SYSCALL_64 on x86)

3. Syscall Dispatching

Syscall Number:

The syscall number is stored in a register (e.g., RAX on x86, R7 on ARM).
Example: __NR_read (syscall number for read()).


Syscall Table:

The kernel uses sys_call_table (array of function pointers) to find the handler.
Example: sys_call_table[__NR_read] points to sys_read().



4. Handler Execution in Process Context
Generic Steps for All Syscalls:

Argument Validation:

Check pointers (e.g., buf in read()) using access_ok()
Copy arguments from user space with copy_from_user() or get_user()


Kernel Function Execution:

Perform the requested operation (e.g., read from a file, send an ioctl command)



File Operations (read/write):

File Descriptor Resolution:

Convert fd to a struct file using fdget().
Check file permissions (FMODE_READ/FMODE_WRITE).


Driver Interaction:

Call the read/write method from the file’s file_operations struct.
Example: For /dev/mydevice, this invokes the driver’s .read function.



I/O Control (ioctl):

The ioctl syscall (sys_ioctl()) calls the driver&rsquo;s .unlocked_ioctl method.
![IOCTL in Kernel Device Drivers#3](./IOCTL in Kernel Device Drivers#3. Integrate into file_operations)

5. Return to User Space:

Result is stored in eax/r0, and the kernel restores user registers
Execute iret (x86) or exception return (ARM) to resume user-mode execution.


4. Device File Operations
Character devices (e.g., /dev/char_dev) expose operations via file_operations:'><meta name=author content><link rel=canonical href=https://rishav-singh-0.github.io/posts/system-call-software-interrupt/><link crossorigin=anonymous href=/assets/css/stylesheet.2211ca3164be7830024f6aad2b3a2e520843a64f8f048445c3401c1249aa051d.css integrity="sha256-IhHKMWS+eDACT2qtKzouUghDpk+PBIRFw0AcEkmqBR0=" rel="preload stylesheet" as=style><link rel=icon href=https://rishav-singh-0.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://rishav-singh-0.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://rishav-singh-0.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://rishav-singh-0.github.io/apple-touch-icon.png><link rel=mask-icon href=https://rishav-singh-0.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://rishav-singh-0.github.io/posts/system-call-software-interrupt/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://rishav-singh-0.github.io/posts/system-call-software-interrupt/"><meta property="og:site_name" content="Rishav's Digital Garden"><meta property="og:title" content="System Call (Software Interrupt)"><meta property="og:description" content='1. System Call Basics System calls (syscalls) are the interface for user-space programs to request services from the kernel. Examples include:
File I/O: read(), write(), open(), close(). Device Control: ioctl(). Signal Handling: kill(), signal(). 2. System Call Table and Registration Syscall Table: A table (sys_call_table) maps syscall numbers to handler functions. Architecture-Specific: x86: Defined in arch/x86/entry/syscalls/syscall_64.tbl. ARM: Defined in arch/arm/tools/syscall.tbl. Registration: Syscalls are registered at compile time using macros like SYSCALL_DEFINE (e.g., SYSCALL_DEFINE3(write, ...) for write()). For custom syscalls (rare and discouraged), you would: Add an entry to the syscall table. Define the handler using SYSCALL_DEFINE. Recompile the kernel (or use modules for dynamic insertion). 3. Flow of System Calls 1. User-Space Invocation The libc wrapper (e.g., read(), ioctl()) triggers a software interrupt (int 0x80 on x86) or uses the syscall instruction (modern x86/ARM). // User-space code fd = open("/dev/mydevice", O_RDWR); // Syscall 1: open() read(fd, buf, 100); // Syscall 2: read() ioctl(fd, MY_CMD, arg); // Syscall 3: ioctl() close(fd); // Syscall 4: close() 2. Transition to Kernel Mode Switches to kernel mode (ring 0 on x86, EL1 on ARM). Saves user-space registers (e.g., RIP, RSP, EFLAGS). Jumps to the kernel’s syscall entry point (e.g., entry_SYSCALL_64 on x86) 3. Syscall Dispatching Syscall Number: The syscall number is stored in a register (e.g., RAX on x86, R7 on ARM). Example: __NR_read (syscall number for read()). Syscall Table: The kernel uses sys_call_table (array of function pointers) to find the handler. Example: sys_call_table[__NR_read] points to sys_read(). 4. Handler Execution in Process Context Generic Steps for All Syscalls: Argument Validation: Check pointers (e.g., buf in read()) using access_ok() Copy arguments from user space with copy_from_user() or get_user() Kernel Function Execution: Perform the requested operation (e.g., read from a file, send an ioctl command) File Operations (read/write): File Descriptor Resolution: Convert fd to a struct file using fdget(). Check file permissions (FMODE_READ/FMODE_WRITE). Driver Interaction: Call the read/write method from the file’s file_operations struct. Example: For /dev/mydevice, this invokes the driver’s .read function. I/O Control (ioctl): The ioctl syscall (sys_ioctl()) calls the driver’s .unlocked_ioctl method. ![IOCTL in Kernel Device Drivers#3](./IOCTL in Kernel Device Drivers#3. Integrate into file_operations) 5. Return to User Space: Result is stored in eax/r0, and the kernel restores user registers Execute iret (x86) or exception return (ARM) to resume user-mode execution. 4. Device File Operations Character devices (e.g., /dev/char_dev) expose operations via file_operations:'><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-05-04T14:24:00+00:00"><meta property="article:modified_time" content="2025-05-04T14:24:00+00:00"><meta property="article:tag" content="OS/Interrupt"><meta property="article:tag" content="Platform/Drivers"><meta name=twitter:card content="summary"><meta name=twitter:title content="System Call (Software Interrupt)"><meta name=twitter:description content='1. System Call Basics
System calls (syscalls) are the interface for user-space programs to request services from the kernel. Examples include:

File I/O: read(), write(), open(), close().
Device Control: ioctl().
Signal Handling: kill(), signal().


2. System Call Table and Registration
Syscall Table:

A table (sys_call_table) maps syscall numbers to handler functions.
Architecture-Specific:

x86: Defined in arch/x86/entry/syscalls/syscall_64.tbl.
ARM: Defined in arch/arm/tools/syscall.tbl.


Registration:

Syscalls are registered at compile time using macros like SYSCALL_DEFINE (e.g., SYSCALL_DEFINE3(write, ...) for write()).
For custom syscalls (rare and discouraged), you would:

Add an entry to the syscall table.
Define the handler using SYSCALL_DEFINE.
Recompile the kernel (or use modules for dynamic insertion).






3. Flow of System Calls
1. User-Space Invocation

The libc wrapper (e.g., read(), ioctl()) triggers a software interrupt (int 0x80 on x86) or uses the syscall instruction (modern x86/ARM).

// User-space code
fd = open("/dev/mydevice", O_RDWR);  // Syscall 1: open()
read(fd, buf, 100);                  // Syscall 2: read()
ioctl(fd, MY_CMD, arg);              // Syscall 3: ioctl()
close(fd);                           // Syscall 4: close()
2. Transition to Kernel Mode

Switches to kernel mode (ring 0 on x86, EL1 on ARM).
Saves user-space registers (e.g., RIP, RSP, EFLAGS).
Jumps to the kernel&rsquo;s syscall entry point (e.g., entry_SYSCALL_64 on x86)

3. Syscall Dispatching

Syscall Number:

The syscall number is stored in a register (e.g., RAX on x86, R7 on ARM).
Example: __NR_read (syscall number for read()).


Syscall Table:

The kernel uses sys_call_table (array of function pointers) to find the handler.
Example: sys_call_table[__NR_read] points to sys_read().



4. Handler Execution in Process Context
Generic Steps for All Syscalls:

Argument Validation:

Check pointers (e.g., buf in read()) using access_ok()
Copy arguments from user space with copy_from_user() or get_user()


Kernel Function Execution:

Perform the requested operation (e.g., read from a file, send an ioctl command)



File Operations (read/write):

File Descriptor Resolution:

Convert fd to a struct file using fdget().
Check file permissions (FMODE_READ/FMODE_WRITE).


Driver Interaction:

Call the read/write method from the file’s file_operations struct.
Example: For /dev/mydevice, this invokes the driver’s .read function.



I/O Control (ioctl):

The ioctl syscall (sys_ioctl()) calls the driver&rsquo;s .unlocked_ioctl method.
![IOCTL in Kernel Device Drivers#3](./IOCTL in Kernel Device Drivers#3. Integrate into file_operations)

5. Return to User Space:

Result is stored in eax/r0, and the kernel restores user registers
Execute iret (x86) or exception return (ARM) to resume user-mode execution.


4. Device File Operations
Character devices (e.g., /dev/char_dev) expose operations via file_operations:'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://rishav-singh-0.github.io/posts/"},{"@type":"ListItem","position":2,"name":"System Call (Software Interrupt)","item":"https://rishav-singh-0.github.io/posts/system-call-software-interrupt/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"System Call (Software Interrupt)","name":"System Call (Software Interrupt)","description":"1. System Call Basics System calls (syscalls) are the interface for user-space programs to request services from the kernel. Examples include:\nFile I/O: read(), write(), open(), close(). Device Control: ioctl(). Signal Handling: kill(), signal(). 2. System Call Table and Registration Syscall Table: A table (sys_call_table) maps syscall numbers to handler functions. Architecture-Specific: x86: Defined in arch/x86/entry/syscalls/syscall_64.tbl. ARM: Defined in arch/arm/tools/syscall.tbl. Registration: Syscalls are registered at compile time using macros like SYSCALL_DEFINE (e.g., SYSCALL_DEFINE3(write, ...) for write()). For custom syscalls (rare and discouraged), you would: Add an entry to the syscall table. Define the handler using SYSCALL_DEFINE. Recompile the kernel (or use modules for dynamic insertion). 3. Flow of System Calls 1. User-Space Invocation The libc wrapper (e.g., read(), ioctl()) triggers a software interrupt (int 0x80 on x86) or uses the syscall instruction (modern x86/ARM). // User-space code fd = open(\u0026#34;/dev/mydevice\u0026#34;, O_RDWR); // Syscall 1: open() read(fd, buf, 100); // Syscall 2: read() ioctl(fd, MY_CMD, arg); // Syscall 3: ioctl() close(fd); // Syscall 4: close() 2. Transition to Kernel Mode Switches to kernel mode (ring 0 on x86, EL1 on ARM). Saves user-space registers (e.g., RIP, RSP, EFLAGS). Jumps to the kernel\u0026rsquo;s syscall entry point (e.g., entry_SYSCALL_64 on x86) 3. Syscall Dispatching Syscall Number: The syscall number is stored in a register (e.g., RAX on x86, R7 on ARM). Example: __NR_read (syscall number for read()). Syscall Table: The kernel uses sys_call_table (array of function pointers) to find the handler. Example: sys_call_table[__NR_read] points to sys_read(). 4. Handler Execution in Process Context Generic Steps for All Syscalls: Argument Validation: Check pointers (e.g., buf in read()) using access_ok() Copy arguments from user space with copy_from_user() or get_user() Kernel Function Execution: Perform the requested operation (e.g., read from a file, send an ioctl command) File Operations (read/write): File Descriptor Resolution: Convert fd to a struct file using fdget(). Check file permissions (FMODE_READ/FMODE_WRITE). Driver Interaction: Call the read/write method from the file’s file_operations struct. Example: For /dev/mydevice, this invokes the driver’s .read function. I/O Control (ioctl): The ioctl syscall (sys_ioctl()) calls the driver\u0026rsquo;s .unlocked_ioctl method. ![IOCTL in Kernel Device Drivers#3](./IOCTL in Kernel Device Drivers#3. Integrate into file_operations) 5. Return to User Space: Result is stored in eax/r0, and the kernel restores user registers Execute iret (x86) or exception return (ARM) to resume user-mode execution. 4. Device File Operations Character devices (e.g., /dev/char_dev) expose operations via file_operations:\n","keywords":["OS/Interrupt","Platform/Drivers"],"articleBody":"1. System Call Basics System calls (syscalls) are the interface for user-space programs to request services from the kernel. Examples include:\nFile I/O: read(), write(), open(), close(). Device Control: ioctl(). Signal Handling: kill(), signal(). 2. System Call Table and Registration Syscall Table: A table (sys_call_table) maps syscall numbers to handler functions. Architecture-Specific: x86: Defined in arch/x86/entry/syscalls/syscall_64.tbl. ARM: Defined in arch/arm/tools/syscall.tbl. Registration: Syscalls are registered at compile time using macros like SYSCALL_DEFINE (e.g., SYSCALL_DEFINE3(write, ...) for write()). For custom syscalls (rare and discouraged), you would: Add an entry to the syscall table. Define the handler using SYSCALL_DEFINE. Recompile the kernel (or use modules for dynamic insertion). 3. Flow of System Calls 1. User-Space Invocation The libc wrapper (e.g., read(), ioctl()) triggers a software interrupt (int 0x80 on x86) or uses the syscall instruction (modern x86/ARM). // User-space code fd = open(\"/dev/mydevice\", O_RDWR); // Syscall 1: open() read(fd, buf, 100); // Syscall 2: read() ioctl(fd, MY_CMD, arg); // Syscall 3: ioctl() close(fd); // Syscall 4: close() 2. Transition to Kernel Mode Switches to kernel mode (ring 0 on x86, EL1 on ARM). Saves user-space registers (e.g., RIP, RSP, EFLAGS). Jumps to the kernel’s syscall entry point (e.g., entry_SYSCALL_64 on x86) 3. Syscall Dispatching Syscall Number: The syscall number is stored in a register (e.g., RAX on x86, R7 on ARM). Example: __NR_read (syscall number for read()). Syscall Table: The kernel uses sys_call_table (array of function pointers) to find the handler. Example: sys_call_table[__NR_read] points to sys_read(). 4. Handler Execution in Process Context Generic Steps for All Syscalls: Argument Validation: Check pointers (e.g., buf in read()) using access_ok() Copy arguments from user space with copy_from_user() or get_user() Kernel Function Execution: Perform the requested operation (e.g., read from a file, send an ioctl command) File Operations (read/write): File Descriptor Resolution: Convert fd to a struct file using fdget(). Check file permissions (FMODE_READ/FMODE_WRITE). Driver Interaction: Call the read/write method from the file’s file_operations struct. Example: For /dev/mydevice, this invokes the driver’s .read function. I/O Control (ioctl): The ioctl syscall (sys_ioctl()) calls the driver’s .unlocked_ioctl method. ![IOCTL in Kernel Device Drivers#3](./IOCTL in Kernel Device Drivers#3. Integrate into file_operations) 5. Return to User Space: Result is stored in eax/r0, and the kernel restores user registers Execute iret (x86) or exception return (ARM) to resume user-mode execution. 4. Device File Operations Character devices (e.g., /dev/char_dev) expose operations via file_operations:\nstruct file_operations { ssize_t (*read)(struct file *, char __user *, size_t, loff_t *); ssize_t (*write)(struct file *, const char __user *, size_t, loff_t *); long (*unlocked_ioctl)(struct file *, unsigned int, unsigned long); // ... }; Examples: [../3-Resource/Platform/Character Device Management in Kernel Drivers|Character Device Management in Kernel Drivers]({\u003c ref “/posts/../3-resource/platform/character-device-management-in-kernel-drivers|character-device-management-in-kernel-drivers/” \u003e}}) [../3-Resource/Platform/IOCTL in Kernel Device Drivers|IOCTL in Kernel Device Drivers]({\u003c ref “/posts/../3-resource/platform/ioctl-in-kernel-device-drivers|ioctl-in-kernel-device-drivers/” \u003e}}) 5. Signal Handling (Ctrl+C) Ctrl+C sends a SIGINT to the foreground process. Kernel Flow: The terminal driver (e.g., tty_io.c) receives the interrupt. The kernel’s signal-handling code (kernel/signal.c) delivers SIGINT to the process. The process’s signal handler (if registered via signal() or sigaction()) is invoked. Key APIs: send_signal(): Kernel function to queue a signal. do_signal(): Handles signal delivery during return to user space. 6. Example: Tracing the read() Syscall User-Space: read(fd, buf, 100); // Invokes syscall via libc Kernel-Space: sys_read() resolves fd to a struct file. Calls vfs_read(), which invokes the driver’s .read method. Driver copies data from device to kernel buffer, then to user space using copy_to_user(). 7. Key Kernel APIs and Modules APIs for Syscalls: SYSCALL_DEFINE{0-6}: Define syscall handlers (e.g., SYSCALL_DEFINE3(read, ...)). copy_to_user()/copy_from_user(): Safely copy data between kernel and user space. get_user()/put_user(): Access single values in user memory. APIs for Device Drivers: register_chrdev(): Register a character device. unregister_chrdev(): Unregister a device. class_create()/device_create(): Create device nodes in /dev. APIs for Signals: kill_pid(): Send a signal to a process sigaction(): User-space API to register signal handlers 8. Critical Concepts to Know Syscall Table: Architecture-specific table mapping syscall numbers to handlers. Process Context vs. Interrupt Context: Syscalls run in process context (can sleep). Hardware interrupts run in interrupt context (atomic). Device File Operations: file_operations struct ties syscalls to driver functions. User/Kernel Boundary: Use copy_to_user/copy_from_user to safely exchange data. Signals: Delivered via send_signal and handled during syscall return. References Linux Kernel Documentation: Syscalls: Documentation/admin-guide/sysctl/kernel.rst. Device Drivers: Documentation/driver-api/. Signals: Documentation/core-api/signal.rst. Books: Linux Device Drivers (O’Reilly). link Understanding the Linux Kernel (O’Reilly). link ","wordCount":"710","inLanguage":"en","datePublished":"2025-05-04T14:24:00Z","dateModified":"2025-05-04T14:24:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://rishav-singh-0.github.io/posts/system-call-software-interrupt/"},"publisher":{"@type":"Organization","name":"Rishav's Digital Garden","logo":{"@type":"ImageObject","url":"https://rishav-singh-0.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://rishav-singh-0.github.io/ accesskey=h title="Rishav's Digital Garden (Alt + H)">Rishav's Digital Garden</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://rishav-singh-0.github.io/archives title=Archive><span>Archive</span></a></li><li><a href=https://rishav-singh-0.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://rishav-singh-0.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">System Call (Software Interrupt)</h1><div class=post-meta><span title='2025-05-04 14:24:00 +0000 UTC'>May 4, 2025</span>&nbsp;·&nbsp;4 min</div></header><div class=post-content><h2 id=1-system-call-basics>1. System Call Basics<a hidden class=anchor aria-hidden=true href=#1-system-call-basics>#</a></h2><p>System calls (syscalls) are the interface for user-space programs to request services from the kernel. Examples include:</p><ul><li><strong>File I/O</strong>: <code>read()</code>, <code>write()</code>, <code>open()</code>, <code>close()</code>.</li><li><strong>Device Control</strong>: <code>ioctl()</code>.</li><li><strong>Signal Handling</strong>: <code>kill()</code>, <code>signal()</code>.</li></ul><hr><h2 id=2-system-call-table-and-registration>2. System Call Table and Registration<a hidden class=anchor aria-hidden=true href=#2-system-call-table-and-registration>#</a></h2><h3 id=syscall-table>Syscall Table:<a hidden class=anchor aria-hidden=true href=#syscall-table>#</a></h3><ul><li>A table (<code>sys_call_table</code>) maps syscall numbers to handler functions.</li><li><strong>Architecture-Specific</strong>:<ul><li><strong>x86</strong>: Defined in <code>arch/x86/entry/syscalls/syscall_64.tbl</code>.</li><li><strong>ARM</strong>: Defined in <code>arch/arm/tools/syscall.tbl</code>.</li></ul></li><li><strong>Registration</strong>:<ul><li>Syscalls are registered at compile time using macros like <code>SYSCALL_DEFINE</code> (e.g., <code>SYSCALL_DEFINE3(write, ...)</code> for <code>write()</code>).</li><li>For custom syscalls (rare and discouraged), you would:<ol><li>Add an entry to the syscall table.</li><li>Define the handler using <code>SYSCALL_DEFINE</code>.</li><li>Recompile the kernel (or use modules for dynamic insertion).</li></ol></li></ul></li></ul><hr><h2 id=3-flow-of-system-calls>3. Flow of System Calls<a hidden class=anchor aria-hidden=true href=#3-flow-of-system-calls>#</a></h2><h3 id=1-user-space-invocation>1. User-Space Invocation<a hidden class=anchor aria-hidden=true href=#1-user-space-invocation>#</a></h3><ul><li>The libc wrapper (e.g., <code>read()</code>, <code>ioctl()</code>) triggers a <strong>software interrupt</strong> (<code>int 0x80</code> on x86) or uses the <code>syscall</code> instruction (modern x86/ARM).</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>// User-space code
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>fd <span style=color:#f92672>=</span> <span style=color:#a6e22e>open</span>(<span style=color:#e6db74>&#34;/dev/mydevice&#34;</span>, O_RDWR);  <span style=color:#75715e>// Syscall 1: open()
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>read</span>(fd, buf, <span style=color:#ae81ff>100</span>);                  <span style=color:#75715e>// Syscall 2: read()
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>ioctl</span>(fd, MY_CMD, arg);              <span style=color:#75715e>// Syscall 3: ioctl()
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>close</span>(fd);                           <span style=color:#75715e>// Syscall 4: close()
</span></span></span></code></pre></div><h3 id=2-transition-to-kernel-mode>2. Transition to Kernel Mode<a hidden class=anchor aria-hidden=true href=#2-transition-to-kernel-mode>#</a></h3><ul><li>Switches to kernel mode (ring 0 on x86, EL1 on ARM).</li><li>Saves user-space registers (e.g., RIP, RSP, EFLAGS).</li><li>Jumps to the kernel&rsquo;s syscall entry point (e.g., <code>entry_SYSCALL_64</code> on x86)</li></ul><h3 id=3-syscall-dispatching>3. Syscall Dispatching<a hidden class=anchor aria-hidden=true href=#3-syscall-dispatching>#</a></h3><ul><li><strong>Syscall Number</strong>:<ul><li>The syscall number is stored in a register (e.g., <code>RAX</code> on x86, <code>R7</code> on ARM).</li><li>Example: <code>__NR_read</code> (syscall number for <code>read()</code>).</li></ul></li><li><strong>Syscall Table</strong>:<ul><li>The kernel uses <code>sys_call_table</code> (array of function pointers) to find the handler.</li><li>Example: <code>sys_call_table[__NR_read]</code> points to <code>sys_read()</code>.</li></ul></li></ul><h3 id=4-handler-execution-in-process-context>4. Handler Execution in Process Context<a hidden class=anchor aria-hidden=true href=#4-handler-execution-in-process-context>#</a></h3><h4 id=generic-steps-for-all-syscalls>Generic Steps for All Syscalls:<a hidden class=anchor aria-hidden=true href=#generic-steps-for-all-syscalls>#</a></h4><ol><li>Argument Validation:<ul><li>Check pointers (e.g., <code>buf</code> in <code>read()</code>) using <code>access_ok()</code></li><li>Copy arguments from user space with <code>copy_from_user()</code> or <code>get_user()</code></li></ul></li><li>Kernel Function Execution:<ul><li>Perform the requested operation (e.g., read from a file, send an <code>ioctl</code> command)</li></ul></li></ol><h4 id=file-operations-readwrite>File Operations (<code>read</code>/<code>write</code>):<a hidden class=anchor aria-hidden=true href=#file-operations-readwrite>#</a></h4><ul><li>File Descriptor Resolution:<ul><li>Convert <code>fd</code> to a <code>struct file</code> using <code>fdget()</code>.</li><li>Check file permissions (<code>FMODE_READ</code>/<code>FMODE_WRITE</code>).</li></ul></li><li>Driver Interaction:<ul><li>Call the <code>read</code>/<code>write</code> method from the file’s <code>file_operations</code> struct.</li><li>Example: For <code>/dev/mydevice</code>, this invokes the driver’s <code>.read</code> function.</li></ul></li></ul><h4 id=io-control-ioctl>I/O Control (<code>ioctl</code>):<a hidden class=anchor aria-hidden=true href=#io-control-ioctl>#</a></h4><ul><li>The <code>ioctl</code> syscall (<code>sys_ioctl()</code>) calls the driver&rsquo;s <code>.unlocked_ioctl</code> method.
![IOCTL in Kernel Device Drivers#3](./IOCTL in Kernel Device Drivers#3. Integrate into file_operations)</li></ul><h3 id=5-return-to-user-space>5. Return to User Space:<a hidden class=anchor aria-hidden=true href=#5-return-to-user-space>#</a></h3><ul><li>Result is stored in <code>eax</code>/<code>r0</code>, and the kernel restores user registers</li><li>Execute <code>iret</code> (x86) or exception return (ARM) to resume user-mode execution.</li></ul><hr><h2 id=4-device-file-operations>4. Device File Operations<a hidden class=anchor aria-hidden=true href=#4-device-file-operations>#</a></h2><p>Character devices (e.g., <code>/dev/char_dev</code>) expose operations via <code>file_operations</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>struct</span> file_operations {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>ssize_t</span> (<span style=color:#f92672>*</span>read)(<span style=color:#66d9ef>struct</span> file <span style=color:#f92672>*</span>, <span style=color:#66d9ef>char</span> __user <span style=color:#f92672>*</span>, <span style=color:#66d9ef>size_t</span>, <span style=color:#66d9ef>loff_t</span> <span style=color:#f92672>*</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>ssize_t</span> (<span style=color:#f92672>*</span>write)(<span style=color:#66d9ef>struct</span> file <span style=color:#f92672>*</span>, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> __user <span style=color:#f92672>*</span>, <span style=color:#66d9ef>size_t</span>, <span style=color:#66d9ef>loff_t</span> <span style=color:#f92672>*</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>long</span> (<span style=color:#f92672>*</span>unlocked_ioctl)(<span style=color:#66d9ef>struct</span> file <span style=color:#f92672>*</span>, <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span>);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>};
</span></span></code></pre></div><h3 id=examples>Examples:<a hidden class=anchor aria-hidden=true href=#examples>#</a></h3><ul><li>[../3-Resource/Platform/Character Device Management in Kernel Drivers|Character Device Management in Kernel Drivers]({&lt; ref &ldquo;/posts/../3-resource/platform/character-device-management-in-kernel-drivers|character-device-management-in-kernel-drivers/&rdquo; >}})</li><li>[../3-Resource/Platform/IOCTL in Kernel Device Drivers|IOCTL in Kernel Device Drivers]({&lt; ref &ldquo;/posts/../3-resource/platform/ioctl-in-kernel-device-drivers|ioctl-in-kernel-device-drivers/&rdquo; >}})</li></ul><hr><h2 id=5-signal-handling-ctrlc>5. Signal Handling (Ctrl+C)<a hidden class=anchor aria-hidden=true href=#5-signal-handling-ctrlc>#</a></h2><ul><li><strong>Ctrl+C</strong> sends a <code>SIGINT</code> to the foreground process.</li><li><strong>Kernel Flow</strong>:<ol><li>The terminal driver (e.g., <code>tty_io.c</code>) receives the interrupt.</li><li>The kernel&rsquo;s signal-handling code (<code>kernel/signal.c</code>) delivers <code>SIGINT</code> to the process.</li><li>The process&rsquo;s signal handler (if registered via <code>signal()</code> or <code>sigaction()</code>) is invoked.</li></ol></li><li><strong>Key APIs</strong>:<ul><li><code>send_signal()</code>: Kernel function to queue a signal.</li><li><code>do_signal()</code>: Handles signal delivery during return to user space.</li></ul></li></ul><hr><h2 id=6-example-tracing-thereadsyscall>6. Example: Tracing the <code>read()</code> Syscall<a hidden class=anchor aria-hidden=true href=#6-example-tracing-thereadsyscall>#</a></h2><ol><li><strong>User-Space</strong>:</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#a6e22e>read</span>(fd, buf, <span style=color:#ae81ff>100</span>); <span style=color:#75715e>// Invokes syscall via libc
</span></span></span></code></pre></div><ol start=2><li><strong>Kernel-Space</strong>:</li></ol><ul><li><code>sys_read()</code> resolves <code>fd</code> to a <code>struct file</code>.</li><li>Calls <code>vfs_read()</code>, which invokes the driver’s <code>.read</code> method.</li><li>Driver copies data from device to kernel buffer, then to user space using <code>copy_to_user()</code>.</li></ul><h2 id=7-key-kernel-apis-and-modules>7. Key Kernel APIs and Modules<a hidden class=anchor aria-hidden=true href=#7-key-kernel-apis-and-modules>#</a></h2><h3 id=apis-for-syscalls>APIs for Syscalls:<a hidden class=anchor aria-hidden=true href=#apis-for-syscalls>#</a></h3><ul><li><code>SYSCALL_DEFINE{0-6}</code>: Define syscall handlers (e.g., <code>SYSCALL_DEFINE3(read, ...)</code>).</li><li><code>copy_to_user()</code>/<code>copy_from_user()</code>: Safely copy data between kernel and user space.</li><li><code>get_user()</code>/<code>put_user()</code>: Access single values in user memory.</li></ul><h3 id=apis-for-device-drivers>APIs for Device Drivers:<a hidden class=anchor aria-hidden=true href=#apis-for-device-drivers>#</a></h3><ul><li><code>register_chrdev()</code>: Register a character device.</li><li><code>unregister_chrdev()</code>: Unregister a device.</li><li><code>class_create()</code>/<code>device_create()</code>: Create device nodes in <code>/dev</code>.</li></ul><h3 id=apis-for-signals>APIs for Signals:<a hidden class=anchor aria-hidden=true href=#apis-for-signals>#</a></h3><ul><li><code>kill_pid()</code>: Send a signal to a process</li><li><code>sigaction()</code>: User-space API to register signal handlers</li></ul><hr><h2 id=8-critical-concepts-to-know>8. Critical Concepts to Know<a hidden class=anchor aria-hidden=true href=#8-critical-concepts-to-know>#</a></h2><ol><li><strong>Syscall Table</strong>: Architecture-specific table mapping syscall numbers to handlers.</li><li><strong>Process Context vs. Interrupt Context</strong>:<ul><li>Syscalls run in <strong>process context</strong> (can sleep).</li><li>Hardware interrupts run in <strong>interrupt context</strong> (atomic).</li></ul></li><li><strong>Device File Operations</strong>: <code>file_operations</code> struct ties syscalls to driver functions.</li><li><strong>User/Kernel Boundary</strong>: Use <code>copy_to_user</code>/<code>copy_from_user</code> to safely exchange data.</li><li><strong>Signals</strong>: Delivered via <code>send_signal</code> and handled during syscall return.</li></ol><hr><h2 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h2><ul><li>Linux Kernel Documentation:<ul><li>Syscalls: <code>Documentation/admin-guide/sysctl/kernel.rst</code>.</li><li>Device Drivers: <code>Documentation/driver-api/</code>.</li><li>Signals: <code>Documentation/core-api/signal.rst</code>.</li></ul></li><li>Books:<ul><li><em>Linux Device Drivers</em> (O&rsquo;Reilly). <a href=https://www.oreilly.com/openbook/linuxdrive3/book/>link</a></li><li><em>Understanding the Linux Kernel</em> (O&rsquo;Reilly). <a href=https://www.cs.utexas.edu/~rossbach/cs380p/papers/ulk3.pdf>link</a></li></ul></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://rishav-singh-0.github.io/tags/os/interrupt/>OS/Interrupt</a></li><li><a href=https://rishav-singh-0.github.io/tags/platform/drivers/>Platform/Drivers</a></li></ul><nav class=paginav><a class=prev href=https://rishav-singh-0.github.io/posts/cpu-execution-states-on-arm/><span class=title>« Prev</span><br><span>CPU Execution States on ARM</span>
</a><a class=next href=https://rishav-singh-0.github.io/posts/interrupt-handling-flow/><span class=title>Next »</span><br><span>Interrupt Handling Flow</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://rishav-singh-0.github.io/>Rishav's Digital Garden</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>