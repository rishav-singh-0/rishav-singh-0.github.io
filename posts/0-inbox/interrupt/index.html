<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Interrupt | Rishav's Digital Garden</title><meta name=keywords content="Platform/Kernel,OS/Interrupt"><meta name=description content="Overview
An interrupt is a signal that breaks the normal execution flow to handle an event. When an interrupt occurs, the CPU pauses its current task, jumps to an interrupt service routine (ISR), and after the ISR completes it resumes the original task. In other words, interrupts let hardware or software requests &ldquo;call&rdquo; the CPU’s attention immediately, then let the program continue &ldquo;as if nothing happened&rdquo; after handling it.
Why are interrupts needed?

Avoid Polling: More efficient than continuously checking device status (polling), reducing CPU overhead and increasing system throughput
Real-Time Responsiveness: Essential for systems requiring quick reactions to events

Automotive airbag systems detecting collisions
Network Interface Cards (NICs) processing incoming packets



Interrupt Types

Hardware Interrupts: Triggered by devices (e.g., keyboard, NIC). Managed by the Programmable Interrupt Controller (PIC) or APIC.
Software Interrupts: Generated by software (e.g., int 0x80 for syscalls).
Exceptions: CPU-generated (e.g., divide-by-zero, page faults).

How the Kernel Registers Interrupts

Interrupt Descriptor Table (IDT) Initialization:

At boot, the kernel populates the IDT with default handlers (e.g., for exceptions).
Hardware interrupts are mapped to a generic entry (e.g., common_interrupt on x86).


Device Drivers:

Drivers request a specific IRQ (Interrupt Request Line) using request_irq().
Example:

int request_irq(unsigned int irq, irq_handler_t handler, unsigned long flags,
				const char *name, void *dev);

irq: The interrupt number (e.g., IRQ 1 for keyboard).
handler: The ISR function.
flags: Options like IRQF_SHARED for shared interrupts.
dev: A cookie passed to the ISR (used for shared IRQs).



What happens when an interrupt is occurred?
See Interrupt Handling Flow"><meta name=author content><link rel=canonical href=https://blog.rishavs.in/posts/0-inbox/interrupt/><link crossorigin=anonymous href=/assets/css/stylesheet.93f625d739f1d6a5c6f20c146bc6a8d26b233492b34b2220c54b12fd46a04ded.css integrity="sha256-k/Yl1znx1qXG8gwUa8ao0msjNJKzSyIgxUsS/UagTe0=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.rishavs.in/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.rishavs.in/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.rishavs.in/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.rishavs.in/apple-touch-icon.png><link rel=mask-icon href=https://blog.rishavs.in/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://blog.rishavs.in/posts/0-inbox/interrupt/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://blog.rishavs.in/posts/0-inbox/interrupt/"><meta property="og:site_name" content="Rishav's Digital Garden"><meta property="og:title" content="Interrupt"><meta property="og:description" content="Overview An interrupt is a signal that breaks the normal execution flow to handle an event. When an interrupt occurs, the CPU pauses its current task, jumps to an interrupt service routine (ISR), and after the ISR completes it resumes the original task. In other words, interrupts let hardware or software requests “call” the CPU’s attention immediately, then let the program continue “as if nothing happened” after handling it.
Why are interrupts needed? Avoid Polling: More efficient than continuously checking device status (polling), reducing CPU overhead and increasing system throughput Real-Time Responsiveness: Essential for systems requiring quick reactions to events Automotive airbag systems detecting collisions Network Interface Cards (NICs) processing incoming packets Interrupt Types Hardware Interrupts: Triggered by devices (e.g., keyboard, NIC). Managed by the Programmable Interrupt Controller (PIC) or APIC. Software Interrupts: Generated by software (e.g., int 0x80 for syscalls). Exceptions: CPU-generated (e.g., divide-by-zero, page faults). How the Kernel Registers Interrupts Interrupt Descriptor Table (IDT) Initialization: At boot, the kernel populates the IDT with default handlers (e.g., for exceptions). Hardware interrupts are mapped to a generic entry (e.g., common_interrupt on x86). Device Drivers: Drivers request a specific IRQ (Interrupt Request Line) using request_irq(). Example: int request_irq(unsigned int irq, irq_handler_t handler, unsigned long flags, const char *name, void *dev); irq: The interrupt number (e.g., IRQ 1 for keyboard). handler: The ISR function. flags: Options like IRQF_SHARED for shared interrupts. dev: A cookie passed to the ISR (used for shared IRQs). What happens when an interrupt is occurred? See Interrupt Handling Flow"><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-05-03T12:33:00+00:00"><meta property="article:modified_time" content="2025-05-03T12:33:00+00:00"><meta property="article:tag" content="Platform/Kernel"><meta property="article:tag" content="OS/Interrupt"><meta name=twitter:card content="summary"><meta name=twitter:title content="Interrupt"><meta name=twitter:description content="Overview
An interrupt is a signal that breaks the normal execution flow to handle an event. When an interrupt occurs, the CPU pauses its current task, jumps to an interrupt service routine (ISR), and after the ISR completes it resumes the original task. In other words, interrupts let hardware or software requests &ldquo;call&rdquo; the CPU’s attention immediately, then let the program continue &ldquo;as if nothing happened&rdquo; after handling it.
Why are interrupts needed?

Avoid Polling: More efficient than continuously checking device status (polling), reducing CPU overhead and increasing system throughput
Real-Time Responsiveness: Essential for systems requiring quick reactions to events

Automotive airbag systems detecting collisions
Network Interface Cards (NICs) processing incoming packets



Interrupt Types

Hardware Interrupts: Triggered by devices (e.g., keyboard, NIC). Managed by the Programmable Interrupt Controller (PIC) or APIC.
Software Interrupts: Generated by software (e.g., int 0x80 for syscalls).
Exceptions: CPU-generated (e.g., divide-by-zero, page faults).

How the Kernel Registers Interrupts

Interrupt Descriptor Table (IDT) Initialization:

At boot, the kernel populates the IDT with default handlers (e.g., for exceptions).
Hardware interrupts are mapped to a generic entry (e.g., common_interrupt on x86).


Device Drivers:

Drivers request a specific IRQ (Interrupt Request Line) using request_irq().
Example:

int request_irq(unsigned int irq, irq_handler_t handler, unsigned long flags,
				const char *name, void *dev);

irq: The interrupt number (e.g., IRQ 1 for keyboard).
handler: The ISR function.
flags: Options like IRQF_SHARED for shared interrupts.
dev: A cookie passed to the ISR (used for shared IRQs).



What happens when an interrupt is occurred?
See Interrupt Handling Flow"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.rishavs.in/posts/"},{"@type":"ListItem","position":2,"name":"Interrupt","item":"https://blog.rishavs.in/posts/0-inbox/interrupt/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Interrupt","name":"Interrupt","description":"Overview An interrupt is a signal that breaks the normal execution flow to handle an event. When an interrupt occurs, the CPU pauses its current task, jumps to an interrupt service routine (ISR), and after the ISR completes it resumes the original task. In other words, interrupts let hardware or software requests \u0026ldquo;call\u0026rdquo; the CPU’s attention immediately, then let the program continue \u0026ldquo;as if nothing happened\u0026rdquo; after handling it.\nWhy are interrupts needed? Avoid Polling: More efficient than continuously checking device status (polling), reducing CPU overhead and increasing system throughput Real-Time Responsiveness: Essential for systems requiring quick reactions to events Automotive airbag systems detecting collisions Network Interface Cards (NICs) processing incoming packets Interrupt Types Hardware Interrupts: Triggered by devices (e.g., keyboard, NIC). Managed by the Programmable Interrupt Controller (PIC) or APIC. Software Interrupts: Generated by software (e.g., int 0x80 for syscalls). Exceptions: CPU-generated (e.g., divide-by-zero, page faults). How the Kernel Registers Interrupts Interrupt Descriptor Table (IDT) Initialization: At boot, the kernel populates the IDT with default handlers (e.g., for exceptions). Hardware interrupts are mapped to a generic entry (e.g., common_interrupt on x86). Device Drivers: Drivers request a specific IRQ (Interrupt Request Line) using request_irq(). Example: int request_irq(unsigned int irq, irq_handler_t handler, unsigned long flags, const char *name, void *dev); irq: The interrupt number (e.g., IRQ 1 for keyboard). handler: The ISR function. flags: Options like IRQF_SHARED for shared interrupts. dev: A cookie passed to the ISR (used for shared IRQs). What happens when an interrupt is occurred? See Interrupt Handling Flow\n","keywords":["Platform/Kernel","OS/Interrupt"],"articleBody":"Overview An interrupt is a signal that breaks the normal execution flow to handle an event. When an interrupt occurs, the CPU pauses its current task, jumps to an interrupt service routine (ISR), and after the ISR completes it resumes the original task. In other words, interrupts let hardware or software requests “call” the CPU’s attention immediately, then let the program continue “as if nothing happened” after handling it.\nWhy are interrupts needed? Avoid Polling: More efficient than continuously checking device status (polling), reducing CPU overhead and increasing system throughput Real-Time Responsiveness: Essential for systems requiring quick reactions to events Automotive airbag systems detecting collisions Network Interface Cards (NICs) processing incoming packets Interrupt Types Hardware Interrupts: Triggered by devices (e.g., keyboard, NIC). Managed by the Programmable Interrupt Controller (PIC) or APIC. Software Interrupts: Generated by software (e.g., int 0x80 for syscalls). Exceptions: CPU-generated (e.g., divide-by-zero, page faults). How the Kernel Registers Interrupts Interrupt Descriptor Table (IDT) Initialization: At boot, the kernel populates the IDT with default handlers (e.g., for exceptions). Hardware interrupts are mapped to a generic entry (e.g., common_interrupt on x86). Device Drivers: Drivers request a specific IRQ (Interrupt Request Line) using request_irq(). Example: int request_irq(unsigned int irq, irq_handler_t handler, unsigned long flags, const char *name, void *dev); irq: The interrupt number (e.g., IRQ 1 for keyboard). handler: The ISR function. flags: Options like IRQF_SHARED for shared interrupts. dev: A cookie passed to the ISR (used for shared IRQs). What happens when an interrupt is occurred? See Interrupt Handling Flow\nReferences Linux Kernel: Interrupts - https://youtu.be/ExcpAmWJZw0 https://en.wikipedia.org/wiki/Interrupt_descriptor_table Prompt I want you to explain me what happens in the kernel when the interrupt is called. Start from where the kernel/cpu comes to know that what interrupts even exist, then what interrupt descriptor table is and how the cpu knows about it, how is this table used and managed. Also what the programmer would do to add their own interrupt in any device driver. I know little about top half and bottom half, so your job is to teach me the concepts necessary for actually calling interrupts or isr and routing back to the original cpu state. Give all the kernel apis used in this process. Give relevant example.\n","wordCount":"368","inLanguage":"en","datePublished":"2025-05-03T12:33:00Z","dateModified":"2025-05-03T12:33:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.rishavs.in/posts/0-inbox/interrupt/"},"publisher":{"@type":"Organization","name":"Rishav's Digital Garden","logo":{"@type":"ImageObject","url":"https://blog.rishavs.in/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.rishavs.in/ accesskey=h title="Rishav's Digital Garden (Alt + H)">Rishav's Digital Garden</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.rishavs.in/archives title=Archive><span>Archive</span></a></li><li><a href=https://blog.rishavs.in/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://blog.rishavs.in/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Interrupt</h1><div class=post-meta><span title='2025-05-03 12:33:00 +0000 UTC'>May 3, 2025</span>&nbsp;·&nbsp;2 min</div></header><div class=post-content><h2 id=overview>Overview<a hidden class=anchor aria-hidden=true href=#overview>#</a></h2><p>An <em>interrupt</em> is a signal that breaks the normal execution flow to handle an event. When an interrupt occurs, the CPU <strong>pauses</strong> its current task, jumps to an interrupt service routine (ISR), and after the ISR completes it <strong>resumes</strong> the original task. In other words, interrupts let hardware or software requests &ldquo;call&rdquo; the CPU’s attention immediately, then let the program continue &ldquo;as if nothing happened&rdquo; after handling it.</p><h2 id=why-are-interrupts-needed>Why are interrupts needed?<a hidden class=anchor aria-hidden=true href=#why-are-interrupts-needed>#</a></h2><ul><li>Avoid Polling: More efficient than continuously checking device status (polling), reducing CPU overhead and increasing system throughput</li><li>Real-Time Responsiveness: Essential for systems requiring quick reactions to events<ul><li>Automotive airbag systems detecting collisions</li><li>Network Interface Cards (NICs) processing incoming packets</li></ul></li></ul><h2 id=interrupt-types>Interrupt Types<a hidden class=anchor aria-hidden=true href=#interrupt-types>#</a></h2><ul><li><strong>Hardware Interrupts</strong>: Triggered by devices (e.g., keyboard, NIC). Managed by the <strong>Programmable Interrupt Controller (PIC)</strong> or <strong>APIC</strong>.</li><li><strong>Software Interrupts</strong>: Generated by software (e.g., <code>int 0x80</code> for syscalls).</li><li><strong>Exceptions</strong>: CPU-generated (e.g., divide-by-zero, page faults).</li></ul><h2 id=how-the-kernel-registers-interrupts>How the Kernel Registers Interrupts<a hidden class=anchor aria-hidden=true href=#how-the-kernel-registers-interrupts>#</a></h2><ol><li><a href=/posts/0-inbox/interrupt-descriptor-table-idt/>Interrupt Descriptor Table (IDT)</a> Initialization:<ul><li>At boot, the kernel populates the IDT with default handlers (e.g., for exceptions).</li><li>Hardware interrupts are mapped to a generic entry (e.g., common_interrupt on x86).</li></ul></li><li><strong>Device Drivers</strong>:<ul><li>Drivers request a specific IRQ (Interrupt Request Line) using <code>request_irq()</code>.</li><li>Example:</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>request_irq</span>(<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> irq, <span style=color:#66d9ef>irq_handler_t</span> handler, <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> flags,
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>name, <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>dev);
</span></span></code></pre></div><ul><li><code>irq</code>: The interrupt number (e.g., <code>IRQ 1</code> for keyboard).</li><li><code>handler</code>: The ISR function.</li><li><code>flags</code>: Options like <code>IRQF_SHARED</code> for shared interrupts.</li><li><code>dev</code>: A cookie passed to the ISR (used for shared IRQs).</li></ul></li></ol><h2 id=what-happens-when-an-interrupt-is-occurred>What happens when an interrupt is occurred?<a hidden class=anchor aria-hidden=true href=#what-happens-when-an-interrupt-is-occurred>#</a></h2><p>See <a href=/posts/0-inbox/interrupt-handling-flow/>Interrupt Handling Flow</a></p><h2 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h2><ul><li>Linux Kernel: Interrupts - <a href=https://youtu.be/ExcpAmWJZw0>https://youtu.be/ExcpAmWJZw0</a></li><li><a href=https://en.wikipedia.org/wiki/Interrupt_descriptor_table>https://en.wikipedia.org/wiki/Interrupt_descriptor_table</a></li></ul><h3 id=prompt>Prompt<a hidden class=anchor aria-hidden=true href=#prompt>#</a></h3><p>I want you to explain me what happens in the kernel when the interrupt is called. Start from where the kernel/cpu comes to know that what interrupts even exist, then what interrupt descriptor table is and how the cpu knows about it, how is this table used and managed. Also what the programmer would do to add their own interrupt in any device driver. I know little about top half and bottom half, so your job is to teach me the concepts necessary for actually calling interrupts or isr and routing back to the original cpu state. Give all the kernel apis used in this process. Give relevant example.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.rishavs.in/tags/platform/kernel/>Platform/Kernel</a></li><li><a href=https://blog.rishavs.in/tags/os/interrupt/>OS/Interrupt</a></li></ul><nav class=paginav><a class=prev href=https://blog.rishavs.in/posts/0-inbox/interrupt-questions/><span class=title>« Prev</span><br><span>Interrupt Questions</span>
</a><a class=next href=https://blog.rishavs.in/posts/3-resource/platform/external-toolchain-in-buildroot/><span class=title>Next »</span><br><span>External Toolchain in Buildroot</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://blog.rishavs.in/>Rishav's Digital Garden</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>