<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Interrupt Handling Flow | Rishav's Digital Garden</title><meta name=keywords content="OS/Interrupt"><meta name=description content="1. Interrupt Generation

A hardware device (e.g., NIC, keyboard) raises an interrupt via the Programmable Interrupt Controller (PIC/APIC).
The PIC converts the IRQ line into a vector number and signals the CPU via the INTR/NMI pin.

2. CPU State Save & Context Switch

The CPU finishes the current instruction, saves the process context (registers, PC, flags) to the stack, and disables local interrupts
Switches to the interrupt context (no associated process, interrupts disabled).

3. IDT Lookup

The CPU uses the Interrupt Descriptor Table (IDT) to find the handler address for the interrupt vector.
On ARM, the vector table (similar to x86 IDT) is preconfigured with handlers like handle_level_irq or handle_edge_irq.

4. Top Half Execution

Immediate Actions:
Acknowledge the interrupt at the hardware level (irq_data.chip->irq_ack())
Read device status registers to confirm the interrupt source
Minimal Processing:
Copy critical data (e.g., network packets) to kernel buffers.
Schedule deferred processing via bottom halves (tasklets, softirqs)
APIs: request_irq(), free_irq() for driver-level registration.

5. Bottom Half Execution

Deferred Work:

Process data in safe contexts (e.g., tasklet_schedule() or workqueues).
Runs with interrupts enabled (softirq context) or in process context (workqueues).


Mechanisms:

SoftIRQs: Statically allocated, high-priority (e.g., network RX)
Tasklets: Dynamically allocated, atomic (e.g., USB transfers).
Workqueues: Sleepable, process context (e.g., filesystem I/O) .



6. Interrupt Completion

Send End-of-Interrupt (EOI) to the PIC (e.g., irq_data.chip->irq_eoi())
The result is stored in eax/r0, and the kernel uses iret (x86) or exception return (ARM) to resume user execution.

7. Examples
Network Driver (Hardware Interrupt)

Top Half:

irqreturn_t nic_isr(int irq, void *dev_id) {
    // Read packet from hardware buffer
    tasklet_schedule(&amp;nic_tasklet); // Schedule bottom half
    return IRQ_HANDLED;
}

Bottom Half:

void nic_tasklet_fn(unsigned long data) {
    // Process packets, update kernel networking stack
}
"><meta name=author content><link rel=canonical href=https://blog.rishavs.in/posts/0-inbox/interrupt-handling-flow/><link crossorigin=anonymous href=/assets/css/stylesheet.93f625d739f1d6a5c6f20c146bc6a8d26b233492b34b2220c54b12fd46a04ded.css integrity="sha256-k/Yl1znx1qXG8gwUa8ao0msjNJKzSyIgxUsS/UagTe0=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.rishavs.in/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.rishavs.in/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.rishavs.in/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.rishavs.in/apple-touch-icon.png><link rel=mask-icon href=https://blog.rishavs.in/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://blog.rishavs.in/posts/0-inbox/interrupt-handling-flow/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://blog.rishavs.in/posts/0-inbox/interrupt-handling-flow/"><meta property="og:site_name" content="Rishav's Digital Garden"><meta property="og:title" content="Interrupt Handling Flow"><meta property="og:description" content="1. Interrupt Generation A hardware device (e.g., NIC, keyboard) raises an interrupt via the Programmable Interrupt Controller (PIC/APIC). The PIC converts the IRQ line into a vector number and signals the CPU via the INTR/NMI pin. 2. CPU State Save & Context Switch The CPU finishes the current instruction, saves the process context (registers, PC, flags) to the stack, and disables local interrupts Switches to the interrupt context (no associated process, interrupts disabled). 3. IDT Lookup The CPU uses the Interrupt Descriptor Table (IDT) to find the handler address for the interrupt vector. On ARM, the vector table (similar to x86 IDT) is preconfigured with handlers like handle_level_irq or handle_edge_irq. 4. Top Half Execution Immediate Actions: Acknowledge the interrupt at the hardware level (irq_data.chip->irq_ack()) Read device status registers to confirm the interrupt source Minimal Processing: Copy critical data (e.g., network packets) to kernel buffers. Schedule deferred processing via bottom halves (tasklets, softirqs) APIs: request_irq(), free_irq() for driver-level registration. 5. Bottom Half Execution Deferred Work: Process data in safe contexts (e.g., tasklet_schedule() or workqueues). Runs with interrupts enabled (softirq context) or in process context (workqueues). Mechanisms: SoftIRQs: Statically allocated, high-priority (e.g., network RX) Tasklets: Dynamically allocated, atomic (e.g., USB transfers). Workqueues: Sleepable, process context (e.g., filesystem I/O) . 6. Interrupt Completion Send End-of-Interrupt (EOI) to the PIC (e.g., irq_data.chip->irq_eoi()) The result is stored in eax/r0, and the kernel uses iret (x86) or exception return (ARM) to resume user execution. 7. Examples Network Driver (Hardware Interrupt) Top Half: irqreturn_t nic_isr(int irq, void *dev_id) { // Read packet from hardware buffer tasklet_schedule(&amp;nic_tasklet); // Schedule bottom half return IRQ_HANDLED; } Bottom Half: void nic_tasklet_fn(unsigned long data) { // Process packets, update kernel networking stack } "><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-05-04T14:11:00+00:00"><meta property="article:modified_time" content="2025-05-04T14:11:00+00:00"><meta property="article:tag" content="OS/Interrupt"><meta name=twitter:card content="summary"><meta name=twitter:title content="Interrupt Handling Flow"><meta name=twitter:description content="1. Interrupt Generation

A hardware device (e.g., NIC, keyboard) raises an interrupt via the Programmable Interrupt Controller (PIC/APIC).
The PIC converts the IRQ line into a vector number and signals the CPU via the INTR/NMI pin.

2. CPU State Save & Context Switch

The CPU finishes the current instruction, saves the process context (registers, PC, flags) to the stack, and disables local interrupts
Switches to the interrupt context (no associated process, interrupts disabled).

3. IDT Lookup

The CPU uses the Interrupt Descriptor Table (IDT) to find the handler address for the interrupt vector.
On ARM, the vector table (similar to x86 IDT) is preconfigured with handlers like handle_level_irq or handle_edge_irq.

4. Top Half Execution

Immediate Actions:
Acknowledge the interrupt at the hardware level (irq_data.chip->irq_ack())
Read device status registers to confirm the interrupt source
Minimal Processing:
Copy critical data (e.g., network packets) to kernel buffers.
Schedule deferred processing via bottom halves (tasklets, softirqs)
APIs: request_irq(), free_irq() for driver-level registration.

5. Bottom Half Execution

Deferred Work:

Process data in safe contexts (e.g., tasklet_schedule() or workqueues).
Runs with interrupts enabled (softirq context) or in process context (workqueues).


Mechanisms:

SoftIRQs: Statically allocated, high-priority (e.g., network RX)
Tasklets: Dynamically allocated, atomic (e.g., USB transfers).
Workqueues: Sleepable, process context (e.g., filesystem I/O) .



6. Interrupt Completion

Send End-of-Interrupt (EOI) to the PIC (e.g., irq_data.chip->irq_eoi())
The result is stored in eax/r0, and the kernel uses iret (x86) or exception return (ARM) to resume user execution.

7. Examples
Network Driver (Hardware Interrupt)

Top Half:

irqreturn_t nic_isr(int irq, void *dev_id) {
    // Read packet from hardware buffer
    tasklet_schedule(&amp;nic_tasklet); // Schedule bottom half
    return IRQ_HANDLED;
}

Bottom Half:

void nic_tasklet_fn(unsigned long data) {
    // Process packets, update kernel networking stack
}
"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.rishavs.in/posts/"},{"@type":"ListItem","position":2,"name":"Interrupt Handling Flow","item":"https://blog.rishavs.in/posts/0-inbox/interrupt-handling-flow/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Interrupt Handling Flow","name":"Interrupt Handling Flow","description":"1. Interrupt Generation A hardware device (e.g., NIC, keyboard) raises an interrupt via the Programmable Interrupt Controller (PIC/APIC). The PIC converts the IRQ line into a vector number and signals the CPU via the INTR/NMI pin. 2. CPU State Save \u0026amp; Context Switch The CPU finishes the current instruction, saves the process context (registers, PC, flags) to the stack, and disables local interrupts Switches to the interrupt context (no associated process, interrupts disabled). 3. IDT Lookup The CPU uses the Interrupt Descriptor Table (IDT) to find the handler address for the interrupt vector. On ARM, the vector table (similar to x86 IDT) is preconfigured with handlers like handle_level_irq or handle_edge_irq. 4. Top Half Execution Immediate Actions: Acknowledge the interrupt at the hardware level (irq_data.chip-\u0026gt;irq_ack()) Read device status registers to confirm the interrupt source Minimal Processing: Copy critical data (e.g., network packets) to kernel buffers. Schedule deferred processing via bottom halves (tasklets, softirqs) APIs: request_irq(), free_irq() for driver-level registration. 5. Bottom Half Execution Deferred Work: Process data in safe contexts (e.g., tasklet_schedule() or workqueues). Runs with interrupts enabled (softirq context) or in process context (workqueues). Mechanisms: SoftIRQs: Statically allocated, high-priority (e.g., network RX) Tasklets: Dynamically allocated, atomic (e.g., USB transfers). Workqueues: Sleepable, process context (e.g., filesystem I/O) . 6. Interrupt Completion Send End-of-Interrupt (EOI) to the PIC (e.g., irq_data.chip-\u0026gt;irq_eoi()) The result is stored in eax/r0, and the kernel uses iret (x86) or exception return (ARM) to resume user execution. 7. Examples Network Driver (Hardware Interrupt) Top Half: irqreturn_t nic_isr(int irq, void *dev_id) { // Read packet from hardware buffer tasklet_schedule(\u0026amp;nic_tasklet); // Schedule bottom half return IRQ_HANDLED; } Bottom Half: void nic_tasklet_fn(unsigned long data) { // Process packets, update kernel networking stack } ","keywords":["OS/Interrupt"],"articleBody":"1. Interrupt Generation A hardware device (e.g., NIC, keyboard) raises an interrupt via the Programmable Interrupt Controller (PIC/APIC). The PIC converts the IRQ line into a vector number and signals the CPU via the INTR/NMI pin. 2. CPU State Save \u0026 Context Switch The CPU finishes the current instruction, saves the process context (registers, PC, flags) to the stack, and disables local interrupts Switches to the interrupt context (no associated process, interrupts disabled). 3. IDT Lookup The CPU uses the Interrupt Descriptor Table (IDT) to find the handler address for the interrupt vector. On ARM, the vector table (similar to x86 IDT) is preconfigured with handlers like handle_level_irq or handle_edge_irq. 4. Top Half Execution Immediate Actions: Acknowledge the interrupt at the hardware level (irq_data.chip-\u003eirq_ack()) Read device status registers to confirm the interrupt source Minimal Processing: Copy critical data (e.g., network packets) to kernel buffers. Schedule deferred processing via bottom halves (tasklets, softirqs) APIs: request_irq(), free_irq() for driver-level registration. 5. Bottom Half Execution Deferred Work: Process data in safe contexts (e.g., tasklet_schedule() or workqueues). Runs with interrupts enabled (softirq context) or in process context (workqueues). Mechanisms: SoftIRQs: Statically allocated, high-priority (e.g., network RX) Tasklets: Dynamically allocated, atomic (e.g., USB transfers). Workqueues: Sleepable, process context (e.g., filesystem I/O) . 6. Interrupt Completion Send End-of-Interrupt (EOI) to the PIC (e.g., irq_data.chip-\u003eirq_eoi()) The result is stored in eax/r0, and the kernel uses iret (x86) or exception return (ARM) to resume user execution. 7. Examples Network Driver (Hardware Interrupt) Top Half: irqreturn_t nic_isr(int irq, void *dev_id) { // Read packet from hardware buffer tasklet_schedule(\u0026nic_tasklet); // Schedule bottom half return IRQ_HANDLED; } Bottom Half: void nic_tasklet_fn(unsigned long data) { // Process packets, update kernel networking stack } ","wordCount":"281","inLanguage":"en","datePublished":"2025-05-04T14:11:00Z","dateModified":"2025-05-04T14:11:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.rishavs.in/posts/0-inbox/interrupt-handling-flow/"},"publisher":{"@type":"Organization","name":"Rishav's Digital Garden","logo":{"@type":"ImageObject","url":"https://blog.rishavs.in/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.rishavs.in/ accesskey=h title="Rishav's Digital Garden (Alt + H)">Rishav's Digital Garden</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.rishavs.in/archives title=Archive><span>Archive</span></a></li><li><a href=https://blog.rishavs.in/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://blog.rishavs.in/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Interrupt Handling Flow</h1><div class=post-meta><span title='2025-05-04 14:11:00 +0000 UTC'>May 4, 2025</span>&nbsp;·&nbsp;2 min</div></header><div class=post-content><h3 id=1-interrupt-generation>1. Interrupt Generation<a hidden class=anchor aria-hidden=true href=#1-interrupt-generation>#</a></h3><ul><li>A hardware device (e.g., NIC, keyboard) raises an interrupt via the Programmable Interrupt Controller (PIC/APIC).</li><li>The PIC converts the IRQ line into a vector number and signals the CPU via the INTR/NMI pin.</li></ul><h3 id=2-cpu-state-save--context-switch>2. CPU State Save & Context Switch<a hidden class=anchor aria-hidden=true href=#2-cpu-state-save--context-switch>#</a></h3><ul><li>The CPU finishes the current instruction, saves the process context (registers, PC, flags) to the stack, and disables local interrupts</li><li>Switches to the <strong>interrupt context</strong> (no associated process, interrupts disabled).</li></ul><h3 id=3-idt-lookup>3. IDT Lookup<a hidden class=anchor aria-hidden=true href=#3-idt-lookup>#</a></h3><ul><li>The CPU uses the Interrupt Descriptor Table (IDT) to find the handler address for the interrupt vector.</li><li>On ARM, the vector table (similar to x86 IDT) is preconfigured with handlers like <code>handle_level_irq</code> or <code>handle_edge_irq</code>.</li></ul><h3 id=4-top-half-execution>4. Top Half Execution<a hidden class=anchor aria-hidden=true href=#4-top-half-execution>#</a></h3><ul><li><strong>Immediate Actions</strong>:</li><li>Acknowledge the interrupt at the hardware level (<code>irq_data.chip->irq_ack()</code>)</li><li>Read device status registers to confirm the interrupt source</li><li><strong>Minimal Processing</strong>:</li><li>Copy critical data (e.g., network packets) to kernel buffers.</li><li>Schedule deferred processing via bottom halves (tasklets, softirqs)</li><li><strong>APIs</strong>: <code>request_irq()</code>, <code>free_irq()</code> for driver-level registration.</li></ul><h3 id=5-bottom-half-execution>5. Bottom Half Execution<a hidden class=anchor aria-hidden=true href=#5-bottom-half-execution>#</a></h3><ul><li><strong>Deferred Work</strong>:<ul><li>Process data in safe contexts (e.g., <code>tasklet_schedule()</code> or workqueues).</li><li>Runs with interrupts enabled (softirq context) or in process context (workqueues).</li></ul></li><li><strong>Mechanisms</strong>:<ul><li><strong>SoftIRQs</strong>: Statically allocated, high-priority (e.g., network RX)</li><li><strong>Tasklets</strong>: Dynamically allocated, atomic (e.g., USB transfers).</li><li><strong>Workqueues</strong>: Sleepable, process context (e.g., filesystem I/O) .</li></ul></li></ul><h3 id=6-interrupt-completion>6. Interrupt Completion<a hidden class=anchor aria-hidden=true href=#6-interrupt-completion>#</a></h3><ul><li>Send End-of-Interrupt (EOI) to the PIC (e.g., <code>irq_data.chip->irq_eoi()</code>)</li><li>The result is stored in <code>eax</code>/<code>r0</code>, and the kernel uses <code>iret</code> (x86) or exception return (ARM) to resume user execution.</li></ul><h3 id=7-examples>7. Examples<a hidden class=anchor aria-hidden=true href=#7-examples>#</a></h3><h4 id=network-driver-hardware-interrupt>Network Driver (Hardware Interrupt)<a hidden class=anchor aria-hidden=true href=#network-driver-hardware-interrupt>#</a></h4><ul><li>Top Half:</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>irqreturn_t</span> <span style=color:#a6e22e>nic_isr</span>(<span style=color:#66d9ef>int</span> irq, <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>dev_id) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Read packet from hardware buffer
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>tasklet_schedule</span>(<span style=color:#f92672>&amp;</span>nic_tasklet); <span style=color:#75715e>// Schedule bottom half
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> IRQ_HANDLED;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>Bottom Half:</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>nic_tasklet_fn</span>(<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> data) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Process packets, update kernel networking stack
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.rishavs.in/tags/os/interrupt/>OS/Interrupt</a></li></ul><nav class=paginav><a class=prev href=https://blog.rishavs.in/posts/0-inbox/system-call-software-interrupt/><span class=title>« Prev</span><br><span>System Call (Software Interrupt)</span>
</a><a class=next href=https://blog.rishavs.in/posts/0-inbox/interrupt-questions/><span class=title>Next »</span><br><span>Interrupt Questions</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://blog.rishavs.in/>Rishav's Digital Garden</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>