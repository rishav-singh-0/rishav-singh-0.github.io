<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Kernel Synchronization in Linux | Rishav's Digital Garden</title>
<meta name=keywords content="Platform,Platform/Kernel"><meta name=description content="1. Introduction
In a multitasking environment, multiple processes and threads may need to access shared resources concurrently. Without proper synchronization, race conditions, deadlocks, and data corruption can occur. The Linux kernel provides various synchronization primitives to ensure safe concurrent access while maintaining performance.

2. Spinlocks
Spinlocks are busy-waiting locks used in scenarios where critical sections are short and must be protected from concurrent access.
Key Features:

Suitable for short, critical sections.
Does not sleep, making it ideal for use in interrupt handlers.
If contention occurs, the CPU spins in a loop until the lock is available.
Usage:

spinlock_t my_lock;
spin_lock_init(&amp;my_lock);

spin_lock(&amp;my_lock);
/* Critical section */
spin_unlock(&amp;my_lock);
Types of Spinlocks:"><meta name=author content><link rel=canonical href=https://blog.rishavs.in/posts/kernel-synchronization-in-linux/><link crossorigin=anonymous href=/assets/css/stylesheet.2211ca3164be7830024f6aad2b3a2e520843a64f8f048445c3401c1249aa051d.css integrity="sha256-IhHKMWS+eDACT2qtKzouUghDpk+PBIRFw0AcEkmqBR0=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.rishavs.in/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.rishavs.in/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.rishavs.in/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.rishavs.in/apple-touch-icon.png><link rel=mask-icon href=https://blog.rishavs.in/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://blog.rishavs.in/posts/kernel-synchronization-in-linux/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://blog.rishavs.in/posts/kernel-synchronization-in-linux/"><meta property="og:site_name" content="Rishav's Digital Garden"><meta property="og:title" content="Kernel Synchronization in Linux"><meta property="og:description" content="1. Introduction In a multitasking environment, multiple processes and threads may need to access shared resources concurrently. Without proper synchronization, race conditions, deadlocks, and data corruption can occur. The Linux kernel provides various synchronization primitives to ensure safe concurrent access while maintaining performance.
2. Spinlocks Spinlocks are busy-waiting locks used in scenarios where critical sections are short and must be protected from concurrent access.
Key Features: Suitable for short, critical sections. Does not sleep, making it ideal for use in interrupt handlers. If contention occurs, the CPU spins in a loop until the lock is available. Usage: spinlock_t my_lock; spin_lock_init(&amp;my_lock); spin_lock(&amp;my_lock); /* Critical section */ spin_unlock(&amp;my_lock); Types of Spinlocks:"><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-02-04T18:49:00+00:00"><meta property="article:modified_time" content="2025-02-04T18:49:00+00:00"><meta property="article:tag" content="Platform"><meta property="article:tag" content="Platform/Kernel"><meta name=twitter:card content="summary"><meta name=twitter:title content="Kernel Synchronization in Linux"><meta name=twitter:description content="1. Introduction
In a multitasking environment, multiple processes and threads may need to access shared resources concurrently. Without proper synchronization, race conditions, deadlocks, and data corruption can occur. The Linux kernel provides various synchronization primitives to ensure safe concurrent access while maintaining performance.

2. Spinlocks
Spinlocks are busy-waiting locks used in scenarios where critical sections are short and must be protected from concurrent access.
Key Features:

Suitable for short, critical sections.
Does not sleep, making it ideal for use in interrupt handlers.
If contention occurs, the CPU spins in a loop until the lock is available.
Usage:

spinlock_t my_lock;
spin_lock_init(&amp;my_lock);

spin_lock(&amp;my_lock);
/* Critical section */
spin_unlock(&amp;my_lock);
Types of Spinlocks:"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.rishavs.in/posts/"},{"@type":"ListItem","position":2,"name":"Kernel Synchronization in Linux","item":"https://blog.rishavs.in/posts/kernel-synchronization-in-linux/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Kernel Synchronization in Linux","name":"Kernel Synchronization in Linux","description":"1. Introduction In a multitasking environment, multiple processes and threads may need to access shared resources concurrently. Without proper synchronization, race conditions, deadlocks, and data corruption can occur. The Linux kernel provides various synchronization primitives to ensure safe concurrent access while maintaining performance.\n2. Spinlocks Spinlocks are busy-waiting locks used in scenarios where critical sections are short and must be protected from concurrent access.\nKey Features: Suitable for short, critical sections. Does not sleep, making it ideal for use in interrupt handlers. If contention occurs, the CPU spins in a loop until the lock is available. Usage: spinlock_t my_lock; spin_lock_init(\u0026amp;my_lock); spin_lock(\u0026amp;my_lock); /* Critical section */ spin_unlock(\u0026amp;my_lock); Types of Spinlocks:\n","keywords":["Platform","Platform/Kernel"],"articleBody":"1. Introduction In a multitasking environment, multiple processes and threads may need to access shared resources concurrently. Without proper synchronization, race conditions, deadlocks, and data corruption can occur. The Linux kernel provides various synchronization primitives to ensure safe concurrent access while maintaining performance.\n2. Spinlocks Spinlocks are busy-waiting locks used in scenarios where critical sections are short and must be protected from concurrent access.\nKey Features: Suitable for short, critical sections. Does not sleep, making it ideal for use in interrupt handlers. If contention occurs, the CPU spins in a loop until the lock is available. Usage: spinlock_t my_lock; spin_lock_init(\u0026my_lock); spin_lock(\u0026my_lock); /* Critical section */ spin_unlock(\u0026my_lock); Types of Spinlocks:\nRaw Spinlocks (raw_spinlock_t) - Used in low-level kernel code. Regular Spinlocks (spinlock_t) - Used in general kernel development. Read-Write Spinlocks (rwlock_t) - Allows multiple readers but only one writer. When to use In interrupt handlers. When the critical section is very short. Downsides of Spinlocks Busy-waiting wastes CPU cycles. Not suitable for long critical sections. Can lead to priority inversion issues. 3. Mutexes (Mutual Exclusion) A mutex allows only one thread to access a resource at a time, sleeping if it is unavailable.\nKey Features: Suitable for longer critical sections. Sleeps instead of busy-waiting (unlike spinlocks). Can be used in process context but not in interrupt context. Usage: struct mutex my_mutex; mutex_init(\u0026my_mutex); mutex_lock(\u0026my_mutex); /* Critical section */ mutex_unlock(\u0026my_mutex); When to use: In process context where sleeping is allowed. When the critical section is long. Differences Between Mutexes and Spinlocks: Feature Mutex Spinlock Blocking Yes (sleeps) No (busy-waits) Used in IRQ Handlers No Yes Suitable for Long Critical Sections Yes No CPU Efficient Yes No 4. Semaphores Semaphores are counter-based locks that allow multiple threads to access a resource.\nKey Features: Allows multiple processes to access the resource up to a limit (unlike mutexes). Supports both blocking and non-blocking operations. Used for producer-consumer problems. Usage: struct semaphore my_sem; sema_init(\u0026my_sem, 1); down(\u0026my_sem); // Acquire /* Critical section */ up(\u0026my_sem); // Release down() decrements the semaphore count and blocks if it is 0. up() increments the count and wakes up waiting tasks. When to use: When multiple processes need shared access with limited instances. Binary Semaphore vs. Mutex: A mutex can only be released by the same thread that acquired it. A semaphore can be released by any thread. 5. Barriers Barriers synchronize multiple threads so that they all reach a specific point before continuing. Generally, used in parallel computing for task synchronization. Example:\n#include smp_mb(); // Prevents memory reordering Memory barriers like smp_mb(), smp_rmb(), and smp_wmb() prevent the compiler and CPU from reordering memory operations. When to use: Synchronizing parallel tasks. 6. Read-Copy Update (RCU) RCU allows fast, lockless reads and safe updates.\nKey Features: Readers never block, making it efficient for frequent reads. Writers update data by copying and replacing, avoiding contention. Useful in scenarios with many readers and few writers. Usage: struct my_data { int value; struct rcu_head rcu; }; struct my_data *global_ptr; rcu_read_lock(); struct my_data *data = rcu_dereference(global_ptr); /* Read data safely */ rcu_read_unlock(); Updating: struct my_data *new_data = kmalloc(sizeof(*new_data), GFP_KERNEL); new_data-\u003evalue = 42; rcu_assign_pointer(global_ptr, new_data); synchronize_rcu(); // Ensure old readers have finished When to use: In scenarios with frequent reads and infrequent writes. Advantages of RCU: Lock-free reads (fast access in read-heavy scenarios). Good for linked lists and large datasets. Used in the Linux kernel for managing task lists and network routing tables. 7. Completion Mechanism Used to signal completion of an operation. Usage:\nstruct completion my_completion; init_completion(\u0026my_completion); complete(\u0026my_completion); wait_for_completion(\u0026my_completion); When to use:\nWhen a process needs to wait for an event. 8. Choosing the Right Synchronization Primitive Scenario Recommended Primitive Short critical section in IRQ Spinlock Long critical section Mutex Multiple readers, one writer Read-Write Lock Multiple accesses with blocking Semaphore Synchronizing multiple threads Barrier High-read, low-write scenarios RCU Waiting for an event Completion 9. Conclusion Understanding and correctly using synchronization mechanisms in the Linux kernel is essential to prevent concurrency issues and optimize performance. The right synchronization primitive depends on the execution context, critical section length, and performance requirements.\n","wordCount":"673","inLanguage":"en","datePublished":"2025-02-04T18:49:00Z","dateModified":"2025-02-04T18:49:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.rishavs.in/posts/kernel-synchronization-in-linux/"},"publisher":{"@type":"Organization","name":"Rishav's Digital Garden","logo":{"@type":"ImageObject","url":"https://blog.rishavs.in/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.rishavs.in/ accesskey=h title="Rishav's Digital Garden (Alt + H)">Rishav's Digital Garden</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.rishavs.in/archives title=Archive><span>Archive</span></a></li><li><a href=https://blog.rishavs.in/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://blog.rishavs.in/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Kernel Synchronization in Linux</h1><div class=post-meta><span title='2025-02-04 18:49:00 +0000 UTC'>February 4, 2025</span>&nbsp;·&nbsp;4 min</div></header><div class=post-content><h2 id=1-introduction>1. Introduction<a hidden class=anchor aria-hidden=true href=#1-introduction>#</a></h2><p>In a multitasking environment, multiple processes and threads may need to access shared resources concurrently. Without proper synchronization, race conditions, deadlocks, and data corruption can occur. The Linux kernel provides various synchronization primitives to ensure safe concurrent access while maintaining performance.</p><hr><h2 id=2-spinlocks>2. Spinlocks<a hidden class=anchor aria-hidden=true href=#2-spinlocks>#</a></h2><p>Spinlocks are busy-waiting locks used in scenarios where critical sections are short and must be protected from concurrent access.</p><h3 id=key-features>Key Features:<a hidden class=anchor aria-hidden=true href=#key-features>#</a></h3><ul><li>Suitable for short, critical sections.</li><li>Does <strong>not</strong> sleep, making it ideal for use in interrupt handlers.</li><li>If contention occurs, the CPU <strong>spins in a loop</strong> until the lock is available.
<strong>Usage:</strong></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>spinlock_t</span> my_lock;
</span></span><span style=display:flex><span><span style=color:#a6e22e>spin_lock_init</span>(<span style=color:#f92672>&amp;</span>my_lock);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>spin_lock</span>(<span style=color:#f92672>&amp;</span>my_lock);
</span></span><span style=display:flex><span><span style=color:#75715e>/* Critical section */</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>spin_unlock</span>(<span style=color:#f92672>&amp;</span>my_lock);
</span></span></code></pre></div><p><strong>Types of Spinlocks:</strong></p><ul><li><strong>Raw Spinlocks (<code>raw_spinlock_t</code>)</strong> - Used in low-level kernel code.</li><li><strong>Regular Spinlocks (<code>spinlock_t</code>)</strong> - Used in general kernel development.</li><li><strong>Read-Write Spinlocks (<code>rwlock_t</code>)</strong> - Allows multiple readers but only one writer.</li></ul><h3 id=when-to-use>When to use<a hidden class=anchor aria-hidden=true href=#when-to-use>#</a></h3><ul><li>In interrupt handlers.</li><li>When the critical section is very short.</li></ul><h3 id=downsides-of-spinlocks>Downsides of Spinlocks<a hidden class=anchor aria-hidden=true href=#downsides-of-spinlocks>#</a></h3><ul><li><strong>Busy-waiting</strong> wastes CPU cycles.</li><li>Not suitable for long critical sections.</li><li>Can lead to priority inversion issues.</li></ul><hr><h2 id=3-mutexes-mutual-exclusion>3. Mutexes (Mutual Exclusion)<a hidden class=anchor aria-hidden=true href=#3-mutexes-mutual-exclusion>#</a></h2><p>A mutex allows only one thread to access a resource at a time, sleeping if it is unavailable.</p><h3 id=key-features-1>Key Features:<a hidden class=anchor aria-hidden=true href=#key-features-1>#</a></h3><ul><li>Suitable for longer critical sections.</li><li>Sleeps instead of busy-waiting (unlike spinlocks).</li><li>Can be used in process context but <strong>not in interrupt context</strong>.</li></ul><h3 id=usage>Usage:<a hidden class=anchor aria-hidden=true href=#usage>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>struct</span> mutex my_mutex;
</span></span><span style=display:flex><span><span style=color:#a6e22e>mutex_init</span>(<span style=color:#f92672>&amp;</span>my_mutex);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>mutex_lock</span>(<span style=color:#f92672>&amp;</span>my_mutex);
</span></span><span style=display:flex><span><span style=color:#75715e>/* Critical section */</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>mutex_unlock</span>(<span style=color:#f92672>&amp;</span>my_mutex);
</span></span></code></pre></div><h3 id=when-to-use-1>When to use:<a hidden class=anchor aria-hidden=true href=#when-to-use-1>#</a></h3><ul><li>In process context where sleeping is allowed.</li><li>When the critical section is long.</li></ul><h3 id=differences-between-mutexes-and-spinlocks>Differences Between Mutexes and Spinlocks:<a hidden class=anchor aria-hidden=true href=#differences-between-mutexes-and-spinlocks>#</a></h3><table><thead><tr><th>Feature</th><th>Mutex</th><th>Spinlock</th></tr></thead><tbody><tr><td>Blocking</td><td>Yes (sleeps)</td><td>No (busy-waits)</td></tr><tr><td>Used in IRQ Handlers</td><td>No</td><td>Yes</td></tr><tr><td>Suitable for Long Critical Sections</td><td>Yes</td><td>No</td></tr><tr><td>CPU Efficient</td><td>Yes</td><td>No</td></tr></tbody></table><hr><h2 id=4-semaphores>4. Semaphores<a hidden class=anchor aria-hidden=true href=#4-semaphores>#</a></h2><p>Semaphores are counter-based locks that allow multiple threads to access a resource.</p><h3 id=key-features-2>Key Features:<a hidden class=anchor aria-hidden=true href=#key-features-2>#</a></h3><ul><li>Allows multiple processes to access the resource up to a limit (unlike mutexes).</li><li>Supports both <strong>blocking</strong> and <strong>non-blocking</strong> operations.</li><li>Used for producer-consumer problems.</li></ul><h3 id=usage-1>Usage:<a hidden class=anchor aria-hidden=true href=#usage-1>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>struct</span> semaphore my_sem;
</span></span><span style=display:flex><span><span style=color:#a6e22e>sema_init</span>(<span style=color:#f92672>&amp;</span>my_sem, <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>down</span>(<span style=color:#f92672>&amp;</span>my_sem);  <span style=color:#75715e>// Acquire
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>/* Critical section */</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>up</span>(<span style=color:#f92672>&amp;</span>my_sem);    <span style=color:#75715e>// Release
</span></span></span></code></pre></div><ul><li><code>down()</code> decrements the semaphore count and blocks if it is 0.</li><li><code>up()</code> increments the count and wakes up waiting tasks.</li></ul><h3 id=when-to-use-2>When to use:<a hidden class=anchor aria-hidden=true href=#when-to-use-2>#</a></h3><ul><li>When multiple processes need shared access with limited instances.</li></ul><h3 id=binary-semaphore-vs-mutex>Binary Semaphore vs. Mutex:<a hidden class=anchor aria-hidden=true href=#binary-semaphore-vs-mutex>#</a></h3><ul><li>A <strong>mutex</strong> can only be released by the same thread that acquired it.</li><li>A <strong>semaphore</strong> can be released by any thread.</li></ul><hr><h2 id=5-barriers>5. Barriers<a hidden class=anchor aria-hidden=true href=#5-barriers>#</a></h2><p>Barriers synchronize multiple threads so that they all reach a specific point before continuing. Generally, used in parallel computing for task synchronization.
<strong>Example:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;linux/smp.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>smp_mb</span>();  <span style=color:#75715e>// Prevents memory reordering
</span></span></span></code></pre></div><ul><li>Memory barriers like <code>smp_mb()</code>, <code>smp_rmb()</code>, and <code>smp_wmb()</code> prevent the compiler and CPU from reordering memory operations.</li></ul><h3 id=when-to-use-3>When to use:<a hidden class=anchor aria-hidden=true href=#when-to-use-3>#</a></h3><ul><li>Synchronizing parallel tasks.</li></ul><hr><h2 id=6-read-copy-update-rcu>6. Read-Copy Update (RCU)<a hidden class=anchor aria-hidden=true href=#6-read-copy-update-rcu>#</a></h2><p>RCU allows <strong>fast, lockless reads</strong> and safe updates.</p><h3 id=key-features-3>Key Features:<a hidden class=anchor aria-hidden=true href=#key-features-3>#</a></h3><ul><li><strong>Readers never block</strong>, making it efficient for frequent reads.</li><li><strong>Writers update data by copying and replacing</strong>, avoiding contention.</li><li>Useful in scenarios with <strong>many readers and few writers</strong>.</li></ul><h3 id=usage-2>Usage:<a hidden class=anchor aria-hidden=true href=#usage-2>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>struct</span> my_data {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> value;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> rcu_head rcu;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> my_data <span style=color:#f92672>*</span>global_ptr;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>rcu_read_lock</span>();
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> my_data <span style=color:#f92672>*</span>data <span style=color:#f92672>=</span> <span style=color:#a6e22e>rcu_dereference</span>(global_ptr);
</span></span><span style=display:flex><span><span style=color:#75715e>/* Read data safely */</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>rcu_read_unlock</span>();
</span></span></code></pre></div><h3 id=updating>Updating:<a hidden class=anchor aria-hidden=true href=#updating>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>struct</span> my_data <span style=color:#f92672>*</span>new_data <span style=color:#f92672>=</span> <span style=color:#a6e22e>kmalloc</span>(<span style=color:#66d9ef>sizeof</span>(<span style=color:#f92672>*</span>new_data), GFP_KERNEL);
</span></span><span style=display:flex><span>new_data<span style=color:#f92672>-&gt;</span>value <span style=color:#f92672>=</span> <span style=color:#ae81ff>42</span>;
</span></span><span style=display:flex><span><span style=color:#a6e22e>rcu_assign_pointer</span>(global_ptr, new_data);
</span></span><span style=display:flex><span><span style=color:#a6e22e>synchronize_rcu</span>();  <span style=color:#75715e>// Ensure old readers have finished
</span></span></span></code></pre></div><h3 id=when-to-use-4>When to use:<a hidden class=anchor aria-hidden=true href=#when-to-use-4>#</a></h3><ul><li>In scenarios with frequent reads and infrequent writes.</li></ul><h3 id=advantages-of-rcu>Advantages of RCU:<a hidden class=anchor aria-hidden=true href=#advantages-of-rcu>#</a></h3><ul><li>Lock-free reads (fast access in read-heavy scenarios).</li><li>Good for linked lists and large datasets.</li><li>Used in the Linux kernel for managing task lists and network routing tables.</li></ul><hr><h2 id=7-completion-mechanism>7. Completion Mechanism<a hidden class=anchor aria-hidden=true href=#7-completion-mechanism>#</a></h2><p>Used to signal completion of an operation.
<strong>Usage:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>struct</span> completion my_completion;
</span></span><span style=display:flex><span><span style=color:#a6e22e>init_completion</span>(<span style=color:#f92672>&amp;</span>my_completion);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>complete</span>(<span style=color:#f92672>&amp;</span>my_completion);
</span></span><span style=display:flex><span><span style=color:#a6e22e>wait_for_completion</span>(<span style=color:#f92672>&amp;</span>my_completion);
</span></span></code></pre></div><p><strong>When to use:</strong></p><ul><li>When a process needs to wait for an event.</li></ul><hr><h2 id=8-choosing-the-right-synchronization-primitive>8. Choosing the Right Synchronization Primitive<a hidden class=anchor aria-hidden=true href=#8-choosing-the-right-synchronization-primitive>#</a></h2><table><thead><tr><th>Scenario</th><th>Recommended Primitive</th></tr></thead><tbody><tr><td>Short critical section in IRQ</td><td>Spinlock</td></tr><tr><td>Long critical section</td><td>Mutex</td></tr><tr><td>Multiple readers, one writer</td><td>Read-Write Lock</td></tr><tr><td>Multiple accesses with blocking</td><td>Semaphore</td></tr><tr><td>Synchronizing multiple threads</td><td>Barrier</td></tr><tr><td>High-read, low-write scenarios</td><td>RCU</td></tr><tr><td>Waiting for an event</td><td>Completion</td></tr></tbody></table><hr><h2 id=9-conclusion>9. Conclusion<a hidden class=anchor aria-hidden=true href=#9-conclusion>#</a></h2><p>Understanding and correctly using synchronization mechanisms in the Linux kernel is essential to prevent concurrency issues and optimize performance. The right synchronization primitive depends on the execution context, critical section length, and performance requirements.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.rishavs.in/tags/platform/>Platform</a></li><li><a href=https://blog.rishavs.in/tags/platform/kernel/>Platform/Kernel</a></li></ul><nav class=paginav><a class=prev href=https://blog.rishavs.in/posts/uart/><span class=title>« Prev</span><br><span>UART</span>
</a><a class=next href=https://blog.rishavs.in/posts/monolithic-vs-microkernel/><span class=title>Next »</span><br><span>Monolithic vs Microkernel</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://blog.rishavs.in/>Rishav's Digital Garden</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>