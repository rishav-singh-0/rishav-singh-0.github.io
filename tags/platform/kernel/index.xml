<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Platform/Kernel on Rishav's Digital Garden</title><link>https://blog.rishavs.in/tags/platform/kernel/</link><description>Recent content in Platform/Kernel on Rishav's Digital Garden</description><generator>Hugo -- 0.147.5</generator><language>en-us</language><lastBuildDate>Sat, 03 May 2025 12:33:00 +0000</lastBuildDate><atom:link href="https://blog.rishavs.in/tags/platform/kernel/index.xml" rel="self" type="application/rss+xml"/><item><title>Interrupt</title><link>https://blog.rishavs.in/posts/0-inbox/interrupt/</link><pubDate>Sat, 03 May 2025 12:33:00 +0000</pubDate><guid>https://blog.rishavs.in/posts/0-inbox/interrupt/</guid><description>&lt;h2 id="overview">Overview&lt;/h2>
&lt;p>An &lt;em>interrupt&lt;/em> is a signal that breaks the normal execution flow to handle an event. When an interrupt occurs, the CPU &lt;strong>pauses&lt;/strong> its current task, jumps to an interrupt service routine (ISR), and after the ISR completes it &lt;strong>resumes&lt;/strong> the original task. In other words, interrupts let hardware or software requests &amp;ldquo;call&amp;rdquo; the CPU’s attention immediately, then let the program continue &amp;ldquo;as if nothing happened&amp;rdquo; after handling it.&lt;/p>
&lt;h2 id="why-are-interrupts-needed">Why are interrupts needed?&lt;/h2>
&lt;ul>
&lt;li>Avoid Polling: More efficient than continuously checking device status (polling), reducing CPU overhead and increasing system throughput&lt;/li>
&lt;li>Real-Time Responsiveness: Essential for systems requiring quick reactions to events
&lt;ul>
&lt;li>Automotive airbag systems detecting collisions&lt;/li>
&lt;li>Network Interface Cards (NICs) processing incoming packets&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="interrupt-types">Interrupt Types&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>Hardware Interrupts&lt;/strong>: Triggered by devices (e.g., keyboard, NIC). Managed by the &lt;strong>Programmable Interrupt Controller (PIC)&lt;/strong> or &lt;strong>APIC&lt;/strong>.&lt;/li>
&lt;li>&lt;strong>Software Interrupts&lt;/strong>: Generated by software (e.g., &lt;code>int 0x80&lt;/code> for syscalls).&lt;/li>
&lt;li>&lt;strong>Exceptions&lt;/strong>: CPU-generated (e.g., divide-by-zero, page faults).&lt;/li>
&lt;/ul>
&lt;h2 id="how-the-kernel-registers-interrupts">How the Kernel Registers Interrupts&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="https://blog.rishavs.in/posts/0-inbox/interrupt-descriptor-table-idt/">Interrupt Descriptor Table (IDT)&lt;/a> Initialization:
&lt;ul>
&lt;li>At boot, the kernel populates the IDT with default handlers (e.g., for exceptions).&lt;/li>
&lt;li>Hardware interrupts are mapped to a generic entry (e.g., common_interrupt on x86).&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Device Drivers&lt;/strong>:
&lt;ul>
&lt;li>Drivers request a specific IRQ (Interrupt Request Line) using &lt;code>request_irq()&lt;/code>.&lt;/li>
&lt;li>Example:&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">request_irq&lt;/span>(&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> irq, &lt;span style="color:#66d9ef">irq_handler_t&lt;/span> handler, &lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> flags,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>name, &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>dev);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;code>irq&lt;/code>: The interrupt number (e.g., &lt;code>IRQ 1&lt;/code> for keyboard).&lt;/li>
&lt;li>&lt;code>handler&lt;/code>: The ISR function.&lt;/li>
&lt;li>&lt;code>flags&lt;/code>: Options like &lt;code>IRQF_SHARED&lt;/code> for shared interrupts.&lt;/li>
&lt;li>&lt;code>dev&lt;/code>: A cookie passed to the ISR (used for shared IRQs).&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h2 id="what-happens-when-an-interrupt-is-occurred">What happens when an interrupt is occurred?&lt;/h2>
&lt;p>See &lt;a href="https://blog.rishavs.in/posts/0-inbox/interrupt-handling-flow/">Interrupt Handling Flow&lt;/a>&lt;/p></description></item><item><title>Kernel Synchronization in Linux</title><link>https://blog.rishavs.in/posts/3-resource/platform/kernel-synchronization-in-linux/</link><pubDate>Tue, 04 Feb 2025 18:49:00 +0000</pubDate><guid>https://blog.rishavs.in/posts/3-resource/platform/kernel-synchronization-in-linux/</guid><description>&lt;h2 id="1-introduction">1. Introduction&lt;/h2>
&lt;p>In a multitasking environment, multiple processes and threads may need to access shared resources concurrently. Without proper synchronization, race conditions, deadlocks, and data corruption can occur. The Linux kernel provides various synchronization primitives to ensure safe concurrent access while maintaining performance.&lt;/p>
&lt;hr>
&lt;h2 id="2-spinlocks">2. Spinlocks&lt;/h2>
&lt;p>Spinlocks are busy-waiting locks used in scenarios where critical sections are short and must be protected from concurrent access.&lt;/p>
&lt;h3 id="key-features">Key Features:&lt;/h3>
&lt;ul>
&lt;li>Suitable for short, critical sections.&lt;/li>
&lt;li>Does &lt;strong>not&lt;/strong> sleep, making it ideal for use in interrupt handlers.&lt;/li>
&lt;li>If contention occurs, the CPU &lt;strong>spins in a loop&lt;/strong> until the lock is available.
&lt;strong>Usage:&lt;/strong>&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">spinlock_t&lt;/span> my_lock;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">spin_lock_init&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>my_lock);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">spin_lock&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>my_lock);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/* Critical section */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">spin_unlock&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>my_lock);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>Types of Spinlocks:&lt;/strong>&lt;/p></description></item><item><title>Monolithic vs Microkernel</title><link>https://blog.rishavs.in/posts/3-resource/platform/monolithic-vs-microkernel/</link><pubDate>Tue, 04 Feb 2025 17:28:00 +0000</pubDate><guid>https://blog.rishavs.in/posts/3-resource/platform/monolithic-vs-microkernel/</guid><description>&lt;h3 id="monolithic-kernel">Monolithic Kernel&lt;/h3>
&lt;ul>
&lt;li>All core OS services (memory management, process scheduling, file systems, drivers) reside in kernel space.&lt;/li>
&lt;li>Example: Linux Kernel.&lt;/li>
&lt;li>Pros: Fast performance, directaccess to hardware.&lt;/li>
&lt;li>Cons: Large codebase, difficult debugging, crashes can affect the whole system.&lt;/li>
&lt;/ul>
&lt;h3 id="microkernel">Microkernel&lt;/h3>
&lt;ul>
&lt;li>Minimal core kernel, with most services running in user space.&lt;/li>
&lt;li>Example: QNX, Minix.&lt;/li>
&lt;li>Pros: Stability, modularity, better security.&lt;/li>
&lt;li>Cons: Performance overhead due to inter-process communication (IPC).&lt;/li>
&lt;/ul></description></item><item><title>Kernel Space vs User Space</title><link>https://blog.rishavs.in/posts/3-resource/platform/kernel-space-vs-user-space/</link><pubDate>Tue, 04 Feb 2025 17:23:00 +0000</pubDate><guid>https://blog.rishavs.in/posts/3-resource/platform/kernel-space-vs-user-space/</guid><description>&lt;h2 id="overview">Overview&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>Kernel Space&lt;/strong>: This is where the Linux kernel executes and provides low-level access to hardware, system memory management, process scheduling, and device drivers. Kernel space has privileged access to system resources and is protected from direct user interference. For example, when a user requests data from a hardware sensor, the kernel driver handles communication with the hardware, processes the request, and returns the data to user space through system calls.&lt;/li>
&lt;li>&lt;strong>User Space&lt;/strong>: This is where applications and system utilities run. User-space processes operate with restricted privileges and interact with the kernel via system calls, libraries, and IPC mechanisms. For example, a user-space daemon may monitor the watchdog status by writing to &lt;code>/dev/watchdog&lt;/code>, or a mobile app may read light intensity from &lt;code>/sys/bus/i2c/devices/1-0039/lux&lt;/code>.&lt;/li>
&lt;/ul>
&lt;h2 id="communication-methods-between-kernel-and-user-space">Communication Methods between Kernel and User Space&lt;/h2>
&lt;p>There are several ways to facilitate communication between user space and kernel space in an embedded Linux environment:&lt;/p></description></item><item><title>RTOS (FreeRTOS) vs Linux Kernel</title><link>https://blog.rishavs.in/posts/0-inbox/rtos-free-rtos-vs-linux-kernel/</link><pubDate>Tue, 04 Feb 2025 13:59:00 +0000</pubDate><guid>https://blog.rishavs.in/posts/0-inbox/rtos-free-rtos-vs-linux-kernel/</guid><description>&lt;h2 id="1-overview">1. Overview&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>RTOS (Real-Time Operating System)&lt;/strong>: Designed for deterministic, time-critical applications with low-latency response.&lt;/li>
&lt;li>&lt;strong>Why RTOS over Linux?&lt;/strong>
&lt;ul>
&lt;li>&lt;strong>Deterministic Execution&lt;/strong>: RTOS ensures tasks meet strict timing deadlines, unlike Linux, which has non-deterministic scheduling.&lt;/li>
&lt;li>&lt;strong>Low Overhead&lt;/strong>: RTOS has minimal context switching overhead and no user/kernel space separation.&lt;/li>
&lt;li>&lt;strong>Resource-Constrained Devices&lt;/strong>: Ideal for microcontrollers (MCUs) with limited memory and processing power.&lt;/li>
&lt;li>&lt;strong>Fast Boot Times&lt;/strong>: RTOS boots in milliseconds, while Linux requires a much longer initialization process.&lt;/li>
&lt;li>&lt;strong>Interrupt Handling&lt;/strong>: More responsive to real-time interrupts, whereas Linux introduces latency due to its complex scheduler.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>FreeRTOS&lt;/strong>: A lightweight, open-source RTOS widely used in embedded systems.&lt;/li>
&lt;li>&lt;strong>Linux Kernel&lt;/strong>: A general-purpose OS with multi-user capabilities, used in complex embedded and desktop/server systems.&lt;/li>
&lt;/ul>
&lt;h2 id="2-freertos-vs-linux-kernel-key-differences">2. FreeRTOS vs. Linux Kernel (Key Differences)&lt;/h2>
&lt;h3 id="kernel-vs-user-space">Kernel vs. User Space&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>FreeRTOS:&lt;/strong> It doesn&amp;rsquo;t have the concept of a user space and kernel space like Linux. The whole system is essentially one space, and tasks directly interact with the kernel (RTOS). You can think of FreeRTOS as a single program running with different tasks that can interact with each other or with hardware directly.&lt;/li>
&lt;li>&lt;strong>Linux Kernel:&lt;/strong> Linux operates with a strict separation between user space and kernel space. User applications cannot directly interact with hardware; they must go through system calls, which are handled by the kernel.&lt;/li>
&lt;/ul>
&lt;h3 id="scheduler">Scheduler&lt;/h3>
&lt;h5 id="freertos">FreeRTOS:&lt;/h5>
&lt;ul>
&lt;li>Preemptive, cooperative, or tickless scheduling.&lt;/li>
&lt;li>Supports priority-based scheduling (fixed priority, round-robin, etc.).&lt;/li>
&lt;li>Simple task model, each task runs in its own stack but shares memory.&lt;/li>
&lt;/ul>
&lt;h5 id="linux-kernel">Linux Kernel&lt;/h5>
&lt;ul>
&lt;li>Also has a preemptive scheduler, but it is much more complex, as it must handle multiple users, system calls, different types of scheduling (e.g., real-time, normal tasks), and various priorities.&lt;/li>
&lt;li>Linux is optimized for fairness &lt;strong>CFS (Completely Fair Scheduler)&lt;/strong> and general-purpose multitasking. The FreeRTOS scheduler, by contrast, is simpler and more deterministic.&lt;/li>
&lt;/ul>
&lt;h3 id="processes">Processes&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>FreeRTOS:&lt;/strong> Does not have a &amp;ldquo;process&amp;rdquo; model like Linux. Instead, it has tasks. Tasks in FreeRTOS can be thought of as lightweight threads. FreeRTOS doesn’t manage the memory space for each task in the same way Linux does for processes. All tasks share the same address space and run in the same context.&lt;/li>
&lt;li>&lt;strong>Linux Kernel:&lt;/strong> Linux uses processes, each of which has its own memory space. Processes in Linux can be multi-threaded, and each thread can have different scheduling characteristics. Linux processes are isolated from each other, so one process crashing doesn&amp;rsquo;t affect others.&lt;/li>
&lt;/ul>
&lt;h3 id="memory-management">Memory Management&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>FreeRTOS:&lt;/strong> Memory management is more manual. FreeRTOS does not have sophisticated memory management like Linux. It provides basic functions for allocating fixed-size blocks or dynamic memory pools (&lt;code>pvPortMalloc&lt;/code>, &lt;code>vPortFree&lt;/code>). It doesn&amp;rsquo;t have virtual memory, so all tasks have access to the same memory space, making it much simpler but also more prone to memory corruption if not managed properly.&lt;/li>
&lt;li>&lt;strong>Linux Kernel:&lt;/strong> Linux includes virtual memory, meaning each process has its own virtual address space. It supports advanced features like paging and memory protection. The Linux kernel has a memory management unit (MMU) and sophisticated memory allocators for heap, stack, and memory mapping.&lt;/li>
&lt;/ul>
&lt;h3 id="drivers">Drivers&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>FreeRTOS:&lt;/strong> Drivers in FreeRTOS are usually written to interface directly with the hardware. Embedded developers write hardware-specific drivers for devices such as GPIO, UART, SPI, I2C, etc. The drivers are tightly coupled with the hardware and typically run in the same task context as the rest of the application. Interfacing with hardware is done via direct memory-mapped registers and interrupt service routines (ISRs).&lt;/li>
&lt;li>&lt;strong>Linux Kernel:&lt;/strong> The Linux kernel has a comprehensive set of device drivers for a wide variety of hardware. Drivers in Linux are implemented as kernel modules, which can be dynamically loaded and unloaded. These drivers abstract hardware interactions and often provide a system call interface for user-space applications to interact with hardware.&lt;/li>
&lt;/ul>
&lt;h3 id="gpio-management">GPIO Management&lt;/h3>
&lt;h5 id="freertos-1">FreeRTOS:&lt;/h5>
&lt;ul>
&lt;li>Direct register manipulation or vendor-specific HAL libraries.&lt;/li>
&lt;li>No standard GPIO subsystem like Linux.&lt;/li>
&lt;li>GPIO interrupts are handled using &lt;strong>ISR (Interrupt Service Routines)&lt;/strong> with FreeRTOS primitives like queues for event notification.&lt;/li>
&lt;/ul>
&lt;h5 id="linux-kernel-1">Linux Kernel:&lt;/h5>
&lt;ul>
&lt;li>&lt;strong>GPIO Subsystem&lt;/strong>: Provides an abstraction layer using sysfs, character devices, or device tree bindings.&lt;/li>
&lt;li>Uses kernel interrupt handling with debounce and polling mechanisms.&lt;/li>
&lt;/ul>
&lt;h3 id="interrupt-handling">Interrupt Handling&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>FreeRTOS:&lt;/strong> Interrupt handling is done through &lt;strong>Interrupt Service Routines (ISRs)&lt;/strong>, which are small, time-critical functions that handle hardware interrupts. FreeRTOS provides mechanisms to synchronize tasks with ISRs via &lt;strong>semaphores&lt;/strong> or &lt;strong>queues&lt;/strong>.&lt;/li>
&lt;li>&lt;strong>Linux Kernel:&lt;/strong> Linux also uses ISRs, but in addition to regular interrupts, it has a more complex mechanism for handling asynchronous events, such as software interrupts, tasklets, work queues, etc. The kernel abstracts much of the interrupt management for portability.&lt;/li>
&lt;/ul>
&lt;h3 id="synchronization-mechanisms">Synchronization Mechanisms&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>FreeRTOS:&lt;/strong> Offers simple synchronization primitives like &lt;strong>semaphores&lt;/strong>, &lt;strong>mutexes&lt;/strong>, &lt;strong>queues&lt;/strong>, and &lt;strong>event groups&lt;/strong>. These are lightweight and highly optimized for small systems with limited resources.&lt;/li>
&lt;li>&lt;strong>Linux Kernel:&lt;/strong> Linux also provides synchronization mechanisms like &lt;strong>semaphores&lt;/strong>, &lt;strong>mutexes&lt;/strong>, and &lt;strong>spinlocks&lt;/strong>. However, these mechanisms are more complex and support features like priority inversion prevention, as well as various types of locking for different kernel contexts.&lt;/li>
&lt;/ul>
&lt;h3 id="filesystem-and-io">Filesystem and I/O&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>FreeRTOS:&lt;/strong> By default, FreeRTOS does not provide any filesystem management or complex I/O subsystem. I/O is typically done through simple APIs provided by the BSP or device driver code.&lt;/li>
&lt;li>&lt;strong>Linux Kernel:&lt;/strong> Linux supports a full-fledged filesystem with many types (e.g., ext4, NTFS) and includes complex device I/O management, including file descriptors, blocking/non-blocking I/O, and extensive support for network file systems (NFS, CIFS).&lt;/li>
&lt;/ul>
&lt;h2 id="conclusion">Conclusion:&lt;/h2>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Feature&lt;/th>
&lt;th>FreeRTOS&lt;/th>
&lt;th>Linux Kernel&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Kernel/User Space&lt;/td>
&lt;td>Single space&lt;/td>
&lt;td>Separated&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Scheduler&lt;/td>
&lt;td>Priority-based, Preemptive&lt;/td>
&lt;td>CFS, RT scheduling&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Driver Model&lt;/td>
&lt;td>Direct access, HAL-based&lt;/td>
&lt;td>Kernel module-based&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>GPIO Management&lt;/td>
&lt;td>Direct register access&lt;/td>
&lt;td>Standard GPIO subsystem&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Process Model&lt;/td>
&lt;td>Tasks only&lt;/td>
&lt;td>Processes &amp;amp; Threads&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Memory Management&lt;/td>
&lt;td>Heap-based, no MMU&lt;/td>
&lt;td>Virtual memory, MMU support&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Use Cases&lt;/td>
&lt;td>Real-time, MCUs&lt;/td>
&lt;td>High-performance, SBCs, SoCs&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>FreeRTOS and Linux serve different purposes in embedded systems:&lt;/p></description></item><item><title>Kernel Log Level</title><link>https://blog.rishavs.in/posts/3-resource/platform/kernel-log-level/</link><pubDate>Wed, 20 Nov 2024 16:23:00 +0000</pubDate><guid>https://blog.rishavs.in/posts/3-resource/platform/kernel-log-level/</guid><description>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Number&lt;/th>
&lt;th>Macro&lt;/th>
&lt;th>Log Level&lt;/th>
&lt;th>Description&lt;/th>
&lt;th>Equivalent&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>0&lt;/td>
&lt;td>&lt;code>pr_emerg&lt;/code>&lt;/td>
&lt;td>Emergency&lt;/td>
&lt;td>System is unusable.&lt;/td>
&lt;td>&lt;code>KERN_EMERG&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>1&lt;/td>
&lt;td>&lt;code>pr_alert&lt;/code>&lt;/td>
&lt;td>Alert&lt;/td>
&lt;td>Action must be taken immediately.&lt;/td>
&lt;td>&lt;code>KERN_ALERT&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>2&lt;/td>
&lt;td>&lt;code>pr_crit&lt;/code>&lt;/td>
&lt;td>Critical&lt;/td>
&lt;td>Critical conditions.&lt;/td>
&lt;td>&lt;code>KERN_CRIT&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>3&lt;/td>
&lt;td>&lt;code>pr_err&lt;/code>&lt;/td>
&lt;td>Error&lt;/td>
&lt;td>Error conditions.&lt;/td>
&lt;td>&lt;code>KERN_ERR&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>4&lt;/td>
&lt;td>&lt;code>pr_warn&lt;/code>&lt;/td>
&lt;td>Warning&lt;/td>
&lt;td>Warning conditions.&lt;/td>
&lt;td>&lt;code>KERN_WARNING&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>5&lt;/td>
&lt;td>&lt;code>pr_notice&lt;/code>&lt;/td>
&lt;td>Notice&lt;/td>
&lt;td>Normal but significant condition.&lt;/td>
&lt;td>&lt;code>KERN_NOTICE&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>6&lt;/td>
&lt;td>&lt;code>pr_info&lt;/code>&lt;/td>
&lt;td>Informational&lt;/td>
&lt;td>Informational messages.&lt;/td>
&lt;td>&lt;code>KERN_INFO&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>7&lt;/td>
&lt;td>&lt;code>pr_debug&lt;/code>&lt;/td>
&lt;td>Debug&lt;/td>
&lt;td>Debugging messages.&lt;/td>
&lt;td>&lt;code>KERN_DEBUG&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;ul>
&lt;li>The &lt;strong>number&lt;/strong> corresponds to the log level used by the Linux kernel, with lower numbers indicating higher severity.&lt;/li>
&lt;li>For example, if the log level is set to &lt;code>4&lt;/code> (Warning), only messages from &lt;code>pr_emerg&lt;/code> to &lt;code>pr_warn&lt;/code> will appear in the system logs. Default log level is generally set to 6.&lt;/li>
&lt;li>&lt;/li>
&lt;/ul></description></item><item><title>Compile your Custom Linux Kernel</title><link>https://blog.rishavs.in/posts/3-resource/linux/compile-your-custom-linux-kernel/</link><pubDate>Fri, 17 Sep 2021 23:52:00 +0000</pubDate><guid>https://blog.rishavs.in/posts/3-resource/linux/compile-your-custom-linux-kernel/</guid><description>&lt;h2 id="preparation">Preparation&lt;/h2>
&lt;h3 id="install-dependencies">Install Dependencies&lt;/h3>
&lt;pre tabindex="0">&lt;code>sudo pacman -S base-devel xmlto kmod inetutils bc libelf git --needed
&lt;/code>&lt;/pre>&lt;h3 id="downloading-source-and-local-setup">Downloading source and local setup&lt;/h3>
&lt;p>It is recommended to create a separate build directory for your kernel(s). In this example, the directory kernelbuild will be created in the home directory:&lt;/p>
&lt;pre tabindex="0">&lt;code>mkdir ~/kernelbuild
cd ~/kernelbuild
&lt;/code>&lt;/pre>&lt;p>Goto &lt;a href="https://www.kernel.org/">kernel.org&lt;/a> and download kernel source&lt;/p>
&lt;pre tabindex="0">&lt;code>wget https://cdn.kernel.org/pub/linux/kernel/v5.x/linux-5.14.5.tar.xz
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>Note: you can verify signature of the downloaded tarball if you want&lt;/p>&lt;/blockquote>
&lt;p>Extract tarball&lt;/p>
&lt;pre tabindex="0">&lt;code>tar -xvJf linux-5.14.5.tar.xz
&lt;/code>&lt;/pre>&lt;p>Check
&lt;img src="https://blog.rishavs.in/posts/3-resource/linux/asserts/custom_kernel_tar_ls.png" alt="ls command output"/>&lt;/p></description></item></channel></rss>