<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>OS/Interrupt | Rishav's Digital Garden</title>
<meta name=keywords content><meta name=description content><meta name=author content><link rel=canonical href=https://blog.rishavs.in/tags/os/interrupt/><link crossorigin=anonymous href=/assets/css/stylesheet.2211ca3164be7830024f6aad2b3a2e520843a64f8f048445c3401c1249aa051d.css integrity="sha256-IhHKMWS+eDACT2qtKzouUghDpk+PBIRFw0AcEkmqBR0=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.rishavs.in/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.rishavs.in/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.rishavs.in/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.rishavs.in/apple-touch-icon.png><link rel=mask-icon href=https://blog.rishavs.in/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://blog.rishavs.in/tags/os/interrupt/index.xml><link rel=alternate hreflang=en href=https://blog.rishavs.in/tags/os/interrupt/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://blog.rishavs.in/tags/os/interrupt/"><meta property="og:site_name" content="Rishav's Digital Garden"><meta property="og:title" content="OS/Interrupt"><meta property="og:locale" content="en-us"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="OS/Interrupt"><meta name=twitter:description content></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.rishavs.in/ accesskey=h title="Rishav's Digital Garden (Alt + H)">Rishav's Digital Garden</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.rishavs.in/archives title=Archive><span>Archive</span></a></li><li><a href=https://blog.rishavs.in/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://blog.rishavs.in/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><header class=page-header><h1>OS/Interrupt</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>CPU Execution States on ARM</h2></header><div class=entry-content><p>1. Overview Process Context The kernel executes code on behalf of a user-space process (e.g., handling a system call like read() or write()). Key Properties: Associated with a struct task_struct (process descriptor). Can sleep (use blocking functions like mutex_lock()). Can access user-space memory (via copy_from_user()). Interrupt Context “Atomic context” or “Interrupt context”, The kernel executes code to handle a hardware interrupt or softirq (e.g., a network packet arriving) Key Properties: No associated process (current macro points to an idle task). Cannot sleep (blocking functions like kmalloc(GFP_KERNEL) are forbidden). Runs with interrupts disabled (on the current CPU). 2. CPU Execution States in ARM ARM architectures (e.g., ARMv8-A) define exception levels (ELs) that correspond to CPU execution states:
...</p></div><footer class=entry-footer><span title='2025-05-04 22:55:00 +0000 UTC'>May 4, 2025</span>&nbsp;·&nbsp;3 min</footer><a class=entry-link aria-label="post link to CPU Execution States on ARM" href=https://blog.rishavs.in/posts/cpu-execution-states-on-arm/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>System Call (Software Interrupt)</h2></header><div class=entry-content><p>1. System Call Basics System calls (syscalls) are the interface for user-space programs to request services from the kernel. Examples include:
File I/O: read(), write(), open(), close(). Device Control: ioctl(). Signal Handling: kill(), signal(). 2. System Call Table and Registration Syscall Table: A table (sys_call_table) maps syscall numbers to handler functions. Architecture-Specific: x86: Defined in arch/x86/entry/syscalls/syscall_64.tbl. ARM: Defined in arch/arm/tools/syscall.tbl. Registration: Syscalls are registered at compile time using macros like SYSCALL_DEFINE (e.g., SYSCALL_DEFINE3(write, ...) for write()). For custom syscalls (rare and discouraged), you would: Add an entry to the syscall table. Define the handler using SYSCALL_DEFINE. Recompile the kernel (or use modules for dynamic insertion). 3. Flow of System Calls 1. User-Space Invocation The libc wrapper (e.g., read(), ioctl()) triggers a software interrupt (int 0x80 on x86) or uses the syscall instruction (modern x86/ARM). // User-space code fd = open("/dev/mydevice", O_RDWR); // Syscall 1: open() read(fd, buf, 100); // Syscall 2: read() ioctl(fd, MY_CMD, arg); // Syscall 3: ioctl() close(fd); // Syscall 4: close() 2. Transition to Kernel Mode Switches to kernel mode (ring 0 on x86, EL1 on ARM). Saves user-space registers (e.g., RIP, RSP, EFLAGS). Jumps to the kernel’s syscall entry point (e.g., entry_SYSCALL_64 on x86) 3. Syscall Dispatching Syscall Number: The syscall number is stored in a register (e.g., RAX on x86, R7 on ARM). Example: __NR_read (syscall number for read()). Syscall Table: The kernel uses sys_call_table (array of function pointers) to find the handler. Example: sys_call_table[__NR_read] points to sys_read(). 4. Handler Execution in Process Context Generic Steps for All Syscalls: Argument Validation: Check pointers (e.g., buf in read()) using access_ok() Copy arguments from user space with copy_from_user() or get_user() Kernel Function Execution: Perform the requested operation (e.g., read from a file, send an ioctl command) File Operations (read/write): File Descriptor Resolution: Convert fd to a struct file using fdget(). Check file permissions (FMODE_READ/FMODE_WRITE). Driver Interaction: Call the read/write method from the file’s file_operations struct. Example: For /dev/mydevice, this invokes the driver’s .read function. I/O Control (ioctl): The ioctl syscall (sys_ioctl()) calls the driver’s .unlocked_ioctl method. ![IOCTL in Kernel Device Drivers#3](./IOCTL in Kernel Device Drivers#3. Integrate into file_operations) 5. Return to User Space: Result is stored in eax/r0, and the kernel restores user registers Execute iret (x86) or exception return (ARM) to resume user-mode execution. 4. Device File Operations Character devices (e.g., /dev/char_dev) expose operations via file_operations:
...</p></div><footer class=entry-footer><span title='2025-05-04 14:24:00 +0000 UTC'>May 4, 2025</span>&nbsp;·&nbsp;4 min</footer><a class=entry-link aria-label="post link to System Call (Software Interrupt)" href=https://blog.rishavs.in/posts/system-call-software-interrupt/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Interrupt Handling Flow</h2></header><div class=entry-content><p>1. Interrupt Generation A hardware device (e.g., NIC, keyboard) raises an interrupt via the Programmable Interrupt Controller (PIC/APIC). The PIC converts the IRQ line into a vector number and signals the CPU via the INTR/NMI pin. 2. CPU State Save & Context Switch The CPU finishes the current instruction, saves the process context (registers, PC, flags) to the stack, and disables local interrupts Switches to the interrupt context (no associated process, interrupts disabled). 3. IDT Lookup The CPU uses the Interrupt Descriptor Table (IDT) to find the handler address for the interrupt vector. On ARM, the vector table (similar to x86 IDT) is preconfigured with handlers like handle_level_irq or handle_edge_irq. 4. Top Half Execution Immediate Actions: Acknowledge the interrupt at the hardware level (irq_data.chip->irq_ack()) Read device status registers to confirm the interrupt source Minimal Processing: Copy critical data (e.g., network packets) to kernel buffers. Schedule deferred processing via bottom halves (tasklets, softirqs) APIs: request_irq(), free_irq() for driver-level registration. 5. Bottom Half Execution Deferred Work: Process data in safe contexts (e.g., tasklet_schedule() or workqueues). Runs with interrupts enabled (softirq context) or in process context (workqueues). Mechanisms: SoftIRQs: Statically allocated, high-priority (e.g., network RX) Tasklets: Dynamically allocated, atomic (e.g., USB transfers). Workqueues: Sleepable, process context (e.g., filesystem I/O) . 6. Interrupt Completion Send End-of-Interrupt (EOI) to the PIC (e.g., irq_data.chip->irq_eoi()) The result is stored in eax/r0, and the kernel uses iret (x86) or exception return (ARM) to resume user execution. 7. Examples Network Driver (Hardware Interrupt) Top Half: irqreturn_t nic_isr(int irq, void *dev_id) { // Read packet from hardware buffer tasklet_schedule(&amp;nic_tasklet); // Schedule bottom half return IRQ_HANDLED; } Bottom Half: void nic_tasklet_fn(unsigned long data) { // Process packets, update kernel networking stack }</p></div><footer class=entry-footer><span title='2025-05-04 14:11:00 +0000 UTC'>May 4, 2025</span>&nbsp;·&nbsp;2 min</footer><a class=entry-link aria-label="post link to Interrupt Handling Flow" href=https://blog.rishavs.in/posts/interrupt-handling-flow/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Interrupt Questions</h2></header><div class=entry-content><p>Q1: What happens if another interrupt occurs while a top half (ISR) is executing? Answer:
By default, interrupts are disabled during the top half execution. When the CPU enters the ISR (via the IDT), it automatically clears the Interrupt Flag (IF) on x86 (using cli), preventing further interrupts until the ISR finishes. Exception: Some architectures or configurations (e.g., nested interrupts) allow interrupts to preempt an ISR. For example: IRQF_DISABLED (now deprecated): Previously controlled whether interrupts were disabled during the ISR. Modern kernels typically disable interrupts for all IRQ handlers by default. Threaded interrupts (using IRQF_ONESHOT or IRQF_THREAD): The “top half” runs in a kernel thread with interrupts enabled. Key Takeaway:
...</p></div><footer class=entry-footer><span title='2025-05-04 13:49:00 +0000 UTC'>May 4, 2025</span>&nbsp;·&nbsp;4 min</footer><a class=entry-link aria-label="post link to Interrupt Questions" href=https://blog.rishavs.in/posts/interrupt-questions/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Interrupt</h2></header><div class=entry-content><p>Overview An interrupt is a signal that breaks the normal execution flow to handle an event. When an interrupt occurs, the CPU pauses its current task, jumps to an interrupt service routine (ISR), and after the ISR completes it resumes the original task. In other words, interrupts let hardware or software requests “call” the CPU’s attention immediately, then let the program continue “as if nothing happened” after handling it.
Why are interrupts needed? Avoid Polling: More efficient than continuously checking device status (polling), reducing CPU overhead and increasing system throughput Real-Time Responsiveness: Essential for systems requiring quick reactions to events Automotive airbag systems detecting collisions Network Interface Cards (NICs) processing incoming packets Interrupt Types Hardware Interrupts: Triggered by devices (e.g., keyboard, NIC). Managed by the Programmable Interrupt Controller (PIC) or APIC. Software Interrupts: Generated by software (e.g., int 0x80 for syscalls). Exceptions: CPU-generated (e.g., divide-by-zero, page faults). How the Kernel Registers Interrupts [Interrupt Descriptor Table (IDT)]({&lt; ref “/posts/interrupt-descriptor-table-(idt)/” >}}) Initialization: At boot, the kernel populates the IDT with default handlers (e.g., for exceptions). Hardware interrupts are mapped to a generic entry (e.g., common_interrupt on x86). Device Drivers: Drivers request a specific IRQ (Interrupt Request Line) using request_irq(). Example: int request_irq(unsigned int irq, irq_handler_t handler, unsigned long flags, const char *name, void *dev); irq: The interrupt number (e.g., IRQ 1 for keyboard). handler: The ISR function. flags: Options like IRQF_SHARED for shared interrupts. dev: A cookie passed to the ISR (used for shared IRQs). What happens when an interrupt is occurred? See [Interrupt Handling Flow]({&lt; ref “/posts/interrupt-handling-flow/” >}})
...</p></div><footer class=entry-footer><span title='2025-05-03 12:33:00 +0000 UTC'>May 3, 2025</span>&nbsp;·&nbsp;2 min</footer><a class=entry-link aria-label="post link to Interrupt" href=https://blog.rishavs.in/posts/interrupt/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://blog.rishavs.in/>Rishav's Digital Garden</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>